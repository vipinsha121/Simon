/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.20.1.0 (NJsonSchema v9.11.0.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * @return No Content
     */
    init(): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Account/InitAction";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AdmLoanProductServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * @return OK
     */
    getProductPurposeCodes(productCode: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/admLoanProduct/GetProductPurposeCodes/{productCode}";
        if (productCode === undefined || productCode === null)
            throw new Error("The parameter 'productCode' must be defined.");
        url_ = url_.replace("{productCode}", encodeURIComponent("" + productCode)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductPurposeCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductPurposeCodes(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductPurposeCodes(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    getProductSecondaryPurposeCodes(productCode: string, primaryPurposeCode: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/admLoanProduct/GetProductSecondaryPurposeCodes?";
        if (productCode === undefined || productCode === null)
            throw new Error("The parameter 'productCode' must be defined and cannot be null.");
        else
            url_ += "productCode=" + encodeURIComponent("" + productCode) + "&"; 
        if (primaryPurposeCode === undefined || primaryPurposeCode === null)
            throw new Error("The parameter 'primaryPurposeCode' must be defined and cannot be null.");
        else
            url_ += "primaryPurposeCode=" + encodeURIComponent("" + primaryPurposeCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductSecondaryPurposeCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductSecondaryPurposeCodes(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductSecondaryPurposeCodes(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class AnnouncementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * Get announcements to show on home tab
     * @return OK
     */
    getAnnouncements(numRecords: number, page: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/announcement/GetAnnouncements/{numRecords}/{page}";
        if (numRecords === undefined || numRecords === null)
            throw new Error("The parameter 'numRecords' must be defined.");
        url_ = url_.replace("{numRecords}", encodeURIComponent("" + numRecords)); 
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined.");
        url_ = url_.replace("{page}", encodeURIComponent("" + page)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnnouncements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnnouncements(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetAnnouncements(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class CodeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * To get dropdown data.
     * @return OK
     */
    getDropdownData(key: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/code/GetDrdopdown/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDropdownData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDropdownData(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDropdownData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To get modal for perticular deal.
     * @return OK
     */
    getModalsForDeal(codeName: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/code/GetModalsForDeal/{codeName}";
        if (codeName === undefined || codeName === null)
            throw new Error("The parameter 'codeName' must be defined.");
        url_ = url_.replace("{codeName}", encodeURIComponent("" + codeName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModalsForDeal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModalsForDeal(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetModalsForDeal(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * SB: Get process stage function
     * @param isException (optional) 
     * @return OK
     */
    getProcessStageFunction(processId: string, stageId: string, userId: string, isException?: boolean | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/code/GetProcessStageFunction/{processId}/{stageId}/{userId}?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (stageId === undefined || stageId === null)
            throw new Error("The parameter 'stageId' must be defined.");
        url_ = url_.replace("{stageId}", encodeURIComponent("" + stageId)); 
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        if (isException !== undefined)
            url_ += "isException=" + encodeURIComponent("" + isException) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessStageFunction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessStageFunction(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessStageFunction(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    getProcessStageFunctionObject(processId: string, stageId: string, functionId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/code/GetProcessStageFunctionObject/{processId}/{stageId}/{functionId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (stageId === undefined || stageId === null)
            throw new Error("The parameter 'stageId' must be defined.");
        url_ = url_.replace("{stageId}", encodeURIComponent("" + stageId)); 
        if (functionId === undefined || functionId === null)
            throw new Error("The parameter 'functionId' must be defined.");
        url_ = url_.replace("{functionId}", encodeURIComponent("" + functionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessStageFunctionObject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessStageFunctionObject(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessStageFunctionObject(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    getProcessStageFunctionUser(processId: string, stageId: string, functionId: string, userId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/code/GetProcessStageFunctionUser/{processId}/{stageId}/{functionId}/{userId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (stageId === undefined || stageId === null)
            throw new Error("The parameter 'stageId' must be defined.");
        url_ = url_.replace("{stageId}", encodeURIComponent("" + stageId)); 
        if (functionId === undefined || functionId === null)
            throw new Error("The parameter 'functionId' must be defined.");
        url_ = url_.replace("{functionId}", encodeURIComponent("" + functionId)); 
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessStageFunctionUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessStageFunctionUser(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessStageFunctionUser(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class CollateralServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * Get collateral associated with deal
     * @return OK
     */
    getCollateralForDeal(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/collateral/GetCollateralForDeal/{dealId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCollateralForDeal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCollateralForDeal(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetCollateralForDeal(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get collateral Details by dealId and collateralId
     * @return OK
     */
    getCollateralDetails(dealId: number, collateralId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/collateral/GetCollateralDetails/{dealId}/{collateralId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (collateralId === undefined || collateralId === null)
            throw new Error("The parameter 'collateralId' must be defined.");
        url_ = url_.replace("{collateralId}", encodeURIComponent("" + collateralId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCollateralDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCollateralDetails(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetCollateralDetails(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To check whether deal have any primary collateral
     * @return OK
     */
    getCollateralForPrimaryCheck(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/collateral/GetCollateralForPrimaryCheck/{dealId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCollateralForPrimaryCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCollateralForPrimaryCheck(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetCollateralForPrimaryCheck(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * AM : Get requirements for collateral.
     * @return OK
     */
    getRequirementsCollateral(dealId: number, collateralId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/collateral/GetCollateralRequirements/{dealId}/{collateralId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (collateralId === undefined || collateralId === null)
            throw new Error("The parameter 'collateralId' must be defined.");
        url_ = url_.replace("{collateralId}", encodeURIComponent("" + collateralId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequirementsCollateral(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequirementsCollateral(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequirementsCollateral(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * AM : Get requirement documents
     * @return OK
     */
    getRequirementDocumentsForCollateral(dealId: number, collateralId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/collateral/GetRequirementDocumentsForCollateral/{dealId}/{collateralId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (collateralId === undefined || collateralId === null)
            throw new Error("The parameter 'collateralId' must be defined.");
        url_ = url_.replace("{collateralId}", encodeURIComponent("" + collateralId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequirementDocumentsForCollateral(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequirementDocumentsForCollateral(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequirementDocumentsForCollateral(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * AM: Updatde collateral and create requirement
     * @return OK
     */
    put(collateralDto: CollateralDto): Observable<any> {
        let url_ = this.baseUrl + "/api/Collateral";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(collateralDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * AM : Create new collateral and create new requirement
     * @return OK
     */
    post(collateralDto: CollateralDto): Observable<any> {
        let url_ = this.baseUrl + "/api/Collateral";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(collateralDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * AM: Delete Requirement
     * @return OK
     */
    delete(collateralId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/Collateral?";
        if (collateralId === undefined || collateralId === null)
            throw new Error("The parameter 'collateralId' must be defined and cannot be null.");
        else
            url_ += "collateralId=" + encodeURIComponent("" + collateralId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class ConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * Get CoConfig Value
     * @return OK
     */
    getConfigValue(configId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Config/GetConfigValue/{configId}";
        if (configId === undefined || configId === null)
            throw new Error("The parameter 'configId' must be defined.");
        url_ = url_.replace("{configId}", encodeURIComponent("" + configId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfigValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfigValue(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfigValue(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class DealServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * getDealsList
     * @return OK
     */
    getDealList(userId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/deal/GetDealList?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDealList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDealList(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDealList(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * getDealById
     * @return OK
     */
    getDealById(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/deal/GetDealById?";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined and cannot be null.");
        else
            url_ += "dealId=" + encodeURIComponent("" + dealId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDealById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDealById(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDealById(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get deal user notes
     * @return OK
     */
    getDealUserNote(dealId: number, userId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/deal/GetDealUserNote/{dealId}/{userId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDealUserNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDealUserNote(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDealUserNote(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To get deal entities
     * @return OK
     */
    getDealEntities(dealId: number, type: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/deal/GetDealEntities/{dealId}/{type}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDealEntities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDealEntities(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDealEntities(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get Deal specific dates for Navbar.
     * @return OK
     */
    getDealDates(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/deal/GetDealDates?";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined and cannot be null.");
        else
            url_ += "dealId=" + encodeURIComponent("" + dealId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDealDates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDealDates(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDealDates(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * AM : Get assigned userName for Deal for navbar.
     * @return OK
     */
    getAssignedUserNameForDeal(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/deal/GetAssignedUserNameForDeal?";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined and cannot be null.");
        else
            url_ += "dealId=" + encodeURIComponent("" + dealId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssignedUserNameForDeal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssignedUserNameForDeal(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssignedUserNameForDeal(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get Releted Deals for party.
     * @return OK
     */
    getRelateDeals(partyId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/deal/GetRelateDeals/{partyId}";
        if (partyId === undefined || partyId === null)
            throw new Error("The parameter 'partyId' must be defined.");
        url_ = url_.replace("{partyId}", encodeURIComponent("" + partyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRelateDeals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRelateDeals(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRelateDeals(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    send(dealId: string, user: string, stage: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/deal/Send/{dealId}/{user}/{stage}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (user === undefined || user === null)
            throw new Error("The parameter 'user' must be defined.");
        url_ = url_.replace("{user}", encodeURIComponent("" + user)); 
        if (stage === undefined || stage === null)
            throw new Error("The parameter 'stage' must be defined.");
        url_ = url_.replace("{stage}", encodeURIComponent("" + stage)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSend(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSend(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    getDealEvents(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/deal/GetDealEvents/{dealId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDealEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDealEvents(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDealEvents(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    postDealUserNote(dp: DealUserNoteCustomModel): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/deal/PostDealUserNote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dp);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostDealUserNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostDealUserNote(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processPostDealUserNote(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class DocDefinationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * To Get AdmDocument Definitions.
     * @return OK
     */
    getAdmDocumentDefinitions(): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/DocDefination/GetAdmDocumentDefinitions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdmDocumentDefinitions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdmDocumentDefinitions(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdmDocumentDefinitions(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Gets Document types by entity
     * @return OK
     */
    getDocumenteDefinationByEntity(enityIds: number[], entityType: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/DocDefination/GetDocumenteDefinationByEntity/{entityType}";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(enityIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumenteDefinationByEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumenteDefinationByEntity(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumenteDefinationByEntity(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class DocumentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * Get Documents associated with deal
     * @return OK
     */
    getDocumentsForDeal(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/document/GetDocumentsForDeal/{dealId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentsForDeal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentsForDeal(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentsForDeal(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Gets document by doc id
     * @return OK
     */
    getDocumentById(dealId: number, docId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/document/GetDocumentById/{dealId}/{docId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (docId === undefined || docId === null)
            throw new Error("The parameter 'docId' must be defined.");
        url_ = url_.replace("{docId}", encodeURIComponent("" + docId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentById(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentById(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    updateDocument(document: DocumentCustomModel): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/document/UpdateDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(document);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDocument(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDocument(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    updateMultipleDocuments(documents: DocumentCustomModel[]): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/document/UpdateMultipleDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documents);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMultipleDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMultipleDocuments(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMultipleDocuments(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * PN: API to upload document
                Instead of passing collection of files we should pass single file 
                so it will be easy to show progress bar of each file on UI.
     * @return OK
     */
    uploadDocument(): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/document/UploadDocument";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadDocument(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processUploadDocument(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    view(id: string, fileDownloadModeEnabled: boolean): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/document/View/{id}/{fileDownloadModeEnabled}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (fileDownloadModeEnabled === undefined || fileDownloadModeEnabled === null)
            throw new Error("The parameter 'fileDownloadModeEnabled' must be defined.");
        url_ = url_.replace("{fileDownloadModeEnabled}", encodeURIComponent("" + fileDownloadModeEnabled)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processView(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processView(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    deleteDocumentRequirement(documentId: number, requirementId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/document/DeleteDocumentRequirement?";
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined and cannot be null.");
        else
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&"; 
        if (requirementId === undefined || requirementId === null)
            throw new Error("The parameter 'requirementId' must be defined and cannot be null.");
        else
            url_ += "requirementId=" + encodeURIComponent("" + requirementId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDocumentRequirement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDocumentRequirement(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDocumentRequirement(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    uploadRequirementDocument(): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/document/UploadRequirementDocument";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadRequirementDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadRequirementDocument(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processUploadRequirementDocument(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    updateDocumentDocList(): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/document/UpdateDocumentDocList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDocumentDocList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDocumentDocList(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDocumentDocList(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    activateDeactivateDocument(documentId: number, activeflag: boolean): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/document/ActivateDeactivateDocument?";
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined and cannot be null.");
        else
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&"; 
        if (activeflag === undefined || activeflag === null)
            throw new Error("The parameter 'activeflag' must be defined and cannot be null.");
        else
            url_ += "activeflag=" + encodeURIComponent("" + activeflag) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateDeactivateDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateDeactivateDocument(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processActivateDeactivateDocument(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    saveDocumentRequirement(documentRequirement: DocumentRequirementCustomModel): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/document/SaveDocumentRequirement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentRequirement);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDocumentRequirement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDocumentRequirement(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSaveDocumentRequirement(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    updateDocumentExportFlag(document: DocumentCustomModel): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/document/UpdateDocumentExportFlag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(document);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDocumentExportFlag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDocumentExportFlag(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDocumentExportFlag(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * AM : Download document
     * @return OK
     */
    download(id: string, fileDownloadModeEnabled: boolean, userName: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/document/Download/{id}/{fileDownloadModeEnabled}/{userName}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (fileDownloadModeEnabled === undefined || fileDownloadModeEnabled === null)
            throw new Error("The parameter 'fileDownloadModeEnabled' must be defined.");
        url_ = url_.replace("{fileDownloadModeEnabled}", encodeURIComponent("" + fileDownloadModeEnabled)); 
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownload(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDownload(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * AM : Update downloaded document
     * @return OK
     */
    updateDownloadedDocument(downloadedDocument: DownloadedDocumentCustomModel): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/document/UpdateDownloadedDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(downloadedDocument);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDownloadedDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDownloadedDocument(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDownloadedDocument(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    showAlert(downloadedDocDetailsCustomModel: DownloadedDocDetailsCustomModel): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/document/ShowAlert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(downloadedDocDetailsCustomModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowAlert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowAlert(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processShowAlert(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    getDocumentId(docId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/v1/document/GetDocumentId?";
        if (docId === undefined || docId === null)
            throw new Error("The parameter 'docId' must be defined and cannot be null.");
        else
            url_ += "docId=" + encodeURIComponent("" + docId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentId(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentId(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return OK
     */
    getUserName(userName: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/document/GetUserName?";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined and cannot be null.");
        else
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserName(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserName(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class EcmDocumentManagerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * Get Ecm Documents associated with deal
     * @return OK
     */
    getDealEcmDocumentsList(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/EcmDocumentManager/GetDealEcmDocumentsList/{dealId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDealEcmDocumentsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDealEcmDocumentsList(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDealEcmDocumentsList(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get Ecm exported Documents associated with deal
     * @return OK
     */
    getDealEcmExportedDocumentsList(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/EcmDocumentManager/GetDealEcmExportedDocumentsList/{dealId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDealEcmExportedDocumentsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDealEcmExportedDocumentsList(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDealEcmExportedDocumentsList(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class InboxServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * Gets inbox Details for tab header from CoInbox Table
     * @return OK
     */
    getInboxDetails(inboxId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/inbox/inboxDetails/{inboxId}";
        if (inboxId === undefined || inboxId === null)
            throw new Error("The parameter 'inboxId' must be defined.");
        url_ = url_.replace("{inboxId}", encodeURIComponent("" + inboxId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInboxDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInboxDetails(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetInboxDetails(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @param orderBy (optional) 
     * @param numRecords (optional) 
     * @param page (optional) 
     * @param reverseSort (optional) 
     * @return OK
     */
    getInbox(inboxId: string, user: string, filterValue: string, orderBy?: string | null | undefined, numRecords?: number | null | undefined, page?: number | null | undefined, reverseSort?: boolean | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/inbox/GetInbox?";
        if (inboxId === undefined || inboxId === null)
            throw new Error("The parameter 'inboxId' must be defined and cannot be null.");
        else
            url_ += "inboxId=" + encodeURIComponent("" + inboxId) + "&"; 
        if (user === undefined || user === null)
            throw new Error("The parameter 'user' must be defined and cannot be null.");
        else
            url_ += "user=" + encodeURIComponent("" + user) + "&"; 
        if (filterValue === undefined || filterValue === null)
            throw new Error("The parameter 'filterValue' must be defined and cannot be null.");
        else
            url_ += "filterValue=" + encodeURIComponent("" + filterValue) + "&"; 
        if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&"; 
        if (numRecords !== undefined)
            url_ += "numRecords=" + encodeURIComponent("" + numRecords) + "&"; 
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (reverseSort !== undefined)
            url_ += "reverseSort=" + encodeURIComponent("" + reverseSort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInbox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInbox(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetInbox(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    getCountFromMonitor(monitorId: number, inboxId: string, userId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/inbox/GetCountFromMonitor/{monitorId}/{inboxId}/{userId}";
        if (monitorId === undefined || monitorId === null)
            throw new Error("The parameter 'monitorId' must be defined.");
        url_ = url_.replace("{monitorId}", encodeURIComponent("" + monitorId)); 
        if (inboxId === undefined || inboxId === null)
            throw new Error("The parameter 'inboxId' must be defined.");
        url_ = url_.replace("{inboxId}", encodeURIComponent("" + inboxId)); 
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountFromMonitor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountFromMonitor(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountFromMonitor(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    getUserInboxList(userId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/inbox/GetUserInboxList/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInboxList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInboxList(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInboxList(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    getapprovalForMobile(inboxId: string, userId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/inbox/GetApprovalForMobile?";
        if (inboxId === undefined || inboxId === null)
            throw new Error("The parameter 'inboxId' must be defined and cannot be null.");
        else
            url_ += "inboxId=" + encodeURIComponent("" + inboxId) + "&"; 
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetapprovalForMobile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetapprovalForMobile(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetapprovalForMobile(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class LoanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * Get loans associated with deal
     * @return OK
     */
    getLoansForDeal(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/loan/GetLoansForDeal/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoansForDeal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoansForDeal(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoansForDeal(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get details of perticular loan
     * @return OK
     */
    getLoanDetails(dealId: number, loanId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/loan/GetLoanDetails/{dealId}/{loanId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (loanId === undefined || loanId === null)
            throw new Error("The parameter 'loanId' must be defined.");
        url_ = url_.replace("{loanId}", encodeURIComponent("" + loanId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanDetails(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanDetails(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get available loans for deal.
     * @return OK
     */
    getAvailableLoans(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/loan/GetAvailableLoans/{dealId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableLoans(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableLoans(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetAvailableLoans(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * GetCollateralForLoan
                Gets Collateral associated with Loan
     * @return OK
     */
    getCollateralForLoan(loanId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/loan/GetCollateralForLoan/{loanId}";
        if (loanId === undefined || loanId === null)
            throw new Error("The parameter 'loanId' must be defined.");
        url_ = url_.replace("{loanId}", encodeURIComponent("" + loanId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCollateralForLoan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCollateralForLoan(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetCollateralForLoan(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get Loan check for primary
     * @return OK
     */
    getLoanForPrimaryCheck(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/loan/GetLoanForPrimaryCheck/{dealId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanForPrimaryCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanForPrimaryCheck(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanForPrimaryCheck(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get primary loan associated with deal.
     * @return OK
     */
    getPrimaryLoanByDeal(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/loan/GetPrimaryLoanByDeal?";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined and cannot be null.");
        else
            url_ += "dealId=" + encodeURIComponent("" + dealId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrimaryLoanByDeal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrimaryLoanByDeal(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrimaryLoanByDeal(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get loan as of date.
     * @return OK
     */
    getLoanDeal(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/loan/GetLoanDeal/{dealId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanDeal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanDeal(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanDeal(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return No Content
     */
    update(loan: LoanDto, dealId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/loan/UpdateLoan?";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined and cannot be null.");
        else
            url_ += "dealId=" + encodeURIComponent("" + dealId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loan);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * To Update the loan.
     * @return OK
     */
    saveLoan(loan: LoanDetailsDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/loan/SaveLoan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loan);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveLoan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveLoan(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSaveLoan(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To Update Loan dates
     * @return OK
     */
    saveLoanDates(loan: LoanDetailsDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/loan/SaveLoanDates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loan);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveLoanDates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveLoanDates(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSaveLoanDates(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To Remove Loan
     * @return OK
     */
    removeLoan(loanId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/loan/RemoveLoan/{loanId}";
        if (loanId === undefined || loanId === null)
            throw new Error("The parameter 'loanId' must be defined.");
        url_ = url_.replace("{loanId}", encodeURIComponent("" + loanId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveLoan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveLoan(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveLoan(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    saveNewLoan(loan: LoanDetailsDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/loan/SaveNewLoan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loan);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveNewLoan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveNewLoan(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSaveNewLoan(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get requirements for loan.
     * @return OK
     */
    getRequirementsForLoan(dealId: number, loanId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/loan/GetRequirementsForLoan/{dealId}/{loanId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (loanId === undefined || loanId === null)
            throw new Error("The parameter 'loanId' must be defined.");
        url_ = url_.replace("{loanId}", encodeURIComponent("" + loanId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequirementsForLoan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequirementsForLoan(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequirementsForLoan(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get requirement Documents for loan.
     * @return OK
     */
    getRequirementDocumentsForLoan(dealId: number, loanId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/loan/GetRequirementDocumentsForLoan/{dealId}/{loanId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (loanId === undefined || loanId === null)
            throw new Error("The parameter 'loanId' must be defined.");
        url_ = url_.replace("{loanId}", encodeURIComponent("" + loanId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequirementDocumentsForLoan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequirementDocumentsForLoan(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequirementDocumentsForLoan(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    getLoanConoatDate(loanid: number, dealid: number, reqnameid: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/loan/GetLoanConoatDate/{loanid}/{dealid}/{reqnameid}";
        if (loanid === undefined || loanid === null)
            throw new Error("The parameter 'loanid' must be defined.");
        url_ = url_.replace("{loanid}", encodeURIComponent("" + loanid)); 
        if (dealid === undefined || dealid === null)
            throw new Error("The parameter 'dealid' must be defined.");
        url_ = url_.replace("{dealid}", encodeURIComponent("" + dealid)); 
        if (reqnameid === undefined || reqnameid === null)
            throw new Error("The parameter 'reqnameid' must be defined.");
        url_ = url_.replace("{reqnameid}", encodeURIComponent("" + reqnameid)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanConoatDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanConoatDate(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanConoatDate(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class MessagingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * Get Deal Message Threads
     * @return OK
     */
    getDealConversations(dealId: number, userName: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/GetDealConversations/{dealId}/{userName}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDealConversations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDealConversations(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDealConversations(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get thread messages
     * @return OK
     */
    getThreadMessages(threadID: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/GetThreadMessages/{threadID}";
        if (threadID === undefined || threadID === null)
            throw new Error("The parameter 'threadID' must be defined.");
        url_ = url_.replace("{threadID}", encodeURIComponent("" + threadID)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThreadMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThreadMessages(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetThreadMessages(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To Get Messages For User.
     * @return OK
     */
    getMessagesForUser(): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/GetMessagesForUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessagesForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessagesForUser(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetMessagesForUser(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @param isShowAll (optional) 
     * @return OK
     */
    getAlertsForUser(userId: string, isShowAll?: boolean | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/GetAlertsForUser/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        if (isShowAll !== undefined)
            url_ += "isShowAll=" + encodeURIComponent("" + isShowAll) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAlertsForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAlertsForUser(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetAlertsForUser(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    markAlertAsRead(userId: string, alertId: number, hours: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/MarkAlertAsRead/{userId}/{alertId}/{hours}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        if (alertId === undefined || alertId === null)
            throw new Error("The parameter 'alertId' must be defined.");
        url_ = url_.replace("{alertId}", encodeURIComponent("" + alertId)); 
        if (hours === undefined || hours === null)
            throw new Error("The parameter 'hours' must be defined.");
        url_ = url_.replace("{hours}", encodeURIComponent("" + hours)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAlertAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAlertAsRead(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAlertAsRead(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To Get UnRead Alerts By Hour Range.
     * @return OK
     */
    getUnReadAlertsByHourRange(notificationUserId: string, notificationType: string, hours: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/GetUnReadAlertsByHourRange/{notificationUserId}/{notificationType}/{hours}";
        if (notificationUserId === undefined || notificationUserId === null)
            throw new Error("The parameter 'notificationUserId' must be defined.");
        url_ = url_.replace("{notificationUserId}", encodeURIComponent("" + notificationUserId)); 
        if (notificationType === undefined || notificationType === null)
            throw new Error("The parameter 'notificationType' must be defined.");
        url_ = url_.replace("{notificationType}", encodeURIComponent("" + notificationType)); 
        if (hours === undefined || hours === null)
            throw new Error("The parameter 'hours' must be defined.");
        url_ = url_.replace("{hours}", encodeURIComponent("" + hours)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnReadAlertsByHourRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnReadAlertsByHourRange(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnReadAlertsByHourRange(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To Get User UnRead Messages Count.
     * @return OK
     */
    getUserUnReadMessagesCount(userId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/GetUserUnReadMessagesCount/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserUnReadMessagesCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserUnReadMessagesCount(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserUnReadMessagesCount(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To get deal messages
     * @return OK
     */
    getDealMessages(dealId: number, page: number, pageSize: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/GetDealMessages/{dealId}/{page}/{pageSize}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined.");
        url_ = url_.replace("{page}", encodeURIComponent("" + page)); 
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDealMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDealMessages(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDealMessages(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    markAllAsRead(userid: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/MarkAllAsRead/{userid}";
        if (userid === undefined || userid === null)
            throw new Error("The parameter 'userid' must be defined.");
        url_ = url_.replace("{userid}", encodeURIComponent("" + userid)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllAsRead(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAllAsRead(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    markUserAlertsAsReadByType(notificationUserId: string, notificationType: string, hours: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/MarkUserAlertsAsReadByType/{notificationUserId}/{notificationType}/{hours}";
        if (notificationUserId === undefined || notificationUserId === null)
            throw new Error("The parameter 'notificationUserId' must be defined.");
        url_ = url_.replace("{notificationUserId}", encodeURIComponent("" + notificationUserId)); 
        if (notificationType === undefined || notificationType === null)
            throw new Error("The parameter 'notificationType' must be defined.");
        url_ = url_.replace("{notificationType}", encodeURIComponent("" + notificationType)); 
        if (hours === undefined || hours === null)
            throw new Error("The parameter 'hours' must be defined.");
        url_ = url_.replace("{hours}", encodeURIComponent("" + hours)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkUserAlertsAsReadByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkUserAlertsAsReadByType(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processMarkUserAlertsAsReadByType(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    markMessageAsRead(recipient: string, id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/MarkMessageAsRead/{Id}/{recipient}";
        if (recipient === undefined || recipient === null)
            throw new Error("The parameter 'recipient' must be defined.");
        url_ = url_.replace("{recipient}", encodeURIComponent("" + recipient)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkMessageAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkMessageAsRead(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processMarkMessageAsRead(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    updateMessageUserCount(userId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/UpdateMessageUserCount/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMessageUserCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMessageUserCount(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMessageUserCount(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To get Inbox messages.
     * @param threadId (optional) 
     * @param searchString (optional) 
     * @param sortString (optional) 
     * @param reverseSort (optional) 
     * @return OK
     */
    inboxMessages(userId: string, page: number, threadId?: number | null | undefined, searchString?: string | null | undefined, sortString?: string | null | undefined, reverseSort?: boolean | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/InboxMessages?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (threadId !== undefined)
            url_ += "threadId=" + encodeURIComponent("" + threadId) + "&"; 
        if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&"; 
        if (sortString !== undefined)
            url_ += "sortString=" + encodeURIComponent("" + sortString) + "&"; 
        if (reverseSort !== undefined)
            url_ += "reverseSort=" + encodeURIComponent("" + reverseSort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInboxMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInboxMessages(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processInboxMessages(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * GetMessageThreadForRequirement
     * @return OK
     */
    getMessageThreadForRequirement(requirementId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/GetMessageThreadForRequirement?";
        if (requirementId === undefined || requirementId === null)
            throw new Error("The parameter 'requirementId' must be defined and cannot be null.");
        else
            url_ += "requirementId=" + encodeURIComponent("" + requirementId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessageThreadForRequirement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessageThreadForRequirement(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetMessageThreadForRequirement(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * SB : Save message and return
     * @return OK
     */
    saveMessage(message: MessageDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/SaveMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(message);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveMessage(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSaveMessage(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * SB : Save message thead and return
     * @return OK
     */
    saveThread(messageThread: MessageThreadDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/SaveThread";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(messageThread);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveThread(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveThread(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSaveThread(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * SB : Save message thead and return
     * @return OK
     */
    updateThread(messageThread: MessageThreadDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/UpdateThread";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(messageThread);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateThread(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateThread(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateThread(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Add participants to thread
     * @return OK
     */
    addParticipantToThread(threadId: number, participant: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/AddParticipantToThread/{threadId}/{participant}";
        if (threadId === undefined || threadId === null)
            throw new Error("The parameter 'threadId' must be defined.");
        url_ = url_.replace("{threadId}", encodeURIComponent("" + threadId)); 
        if (participant === undefined || participant === null)
            throw new Error("The parameter 'participant' must be defined.");
        url_ = url_.replace("{participant}", encodeURIComponent("" + participant)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddParticipantToThread(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddParticipantToThread(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processAddParticipantToThread(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Remove participants from thread
     * @return OK
     */
    removeParticipantFromThread(threadId: number, participant: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/RemoveParticipantFromThread/{threadId}/{participant}";
        if (threadId === undefined || threadId === null)
            throw new Error("The parameter 'threadId' must be defined.");
        url_ = url_.replace("{threadId}", encodeURIComponent("" + threadId)); 
        if (participant === undefined || participant === null)
            throw new Error("The parameter 'participant' must be defined.");
        url_ = url_.replace("{participant}", encodeURIComponent("" + participant)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveParticipantFromThread(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveParticipantFromThread(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveParticipantFromThread(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get users for thread
     * @return OK
     */
    getThreadUsers(threadId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/GetThreadUsers/{threadId}";
        if (threadId === undefined || threadId === null)
            throw new Error("The parameter 'threadId' must be defined.");
        url_ = url_.replace("{threadId}", encodeURIComponent("" + threadId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThreadUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThreadUsers(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetThreadUsers(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    synchParticipantsInThread(threadId: number, threadUsers: UserDropdownCustomModel[]): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/SynchParticipants/{threadId}";
        if (threadId === undefined || threadId === null)
            throw new Error("The parameter 'threadId' must be defined.");
        url_ = url_.replace("{threadId}", encodeURIComponent("" + threadId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(threadUsers);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSynchParticipantsInThread(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSynchParticipantsInThread(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSynchParticipantsInThread(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    beginDealConversation(creator: string, dealId: number, threadDetails: any): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/BeginDealConversation/{creator}/{dealId}";
        if (creator === undefined || creator === null)
            throw new Error("The parameter 'creator' must be defined.");
        url_ = url_.replace("{creator}", encodeURIComponent("" + creator)); 
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(threadDetails);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBeginDealConversation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBeginDealConversation(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processBeginDealConversation(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get threads and last message details for user messages
     * @return OK
     */
    getUserMessages(userId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/GetUserMessages/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserMessages(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserMessages(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get Notification Alerts For Portlet
     * @param isShowAll (optional) 
     * @return OK
     */
    getNotificationAlerts(notificationUserId: string, notificationType: string, numRecords: number, page: number, isShowAll?: boolean | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Messaging?";
        if (notificationUserId === undefined || notificationUserId === null)
            throw new Error("The parameter 'notificationUserId' must be defined and cannot be null.");
        else
            url_ += "notificationUserId=" + encodeURIComponent("" + notificationUserId) + "&"; 
        if (notificationType === undefined || notificationType === null)
            throw new Error("The parameter 'notificationType' must be defined and cannot be null.");
        else
            url_ += "notificationType=" + encodeURIComponent("" + notificationType) + "&"; 
        if (numRecords === undefined || numRecords === null)
            throw new Error("The parameter 'numRecords' must be defined and cannot be null.");
        else
            url_ += "numRecords=" + encodeURIComponent("" + numRecords) + "&"; 
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (isShowAll !== undefined)
            url_ += "isShowAll=" + encodeURIComponent("" + isShowAll) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationAlerts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationAlerts(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationAlerts(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * @return OK
     */
    updateNotification(notificationRequestDto: NotificationRequestDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Notification/UpdateNotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(notificationRequestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotification(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotification(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class ParticipantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * Get Participants associated with deal
     * @return OK
     */
    getParticipantForDeal(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Participant/GetForDeal/{dealId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetParticipantForDeal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetParticipantForDeal(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetParticipantForDeal(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get Participants.
     * @return OK
     */
    getUsersForApp(): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Participant/GetUsersForApp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersForApp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersForApp(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersForApp(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * PK : Get Users By Role
     * @return OK
     */
    getUsersByRole(roleid: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Participant/GetUsersByRole/{roleid}";
        if (roleid === undefined || roleid === null)
            throw new Error("The parameter 'roleid' must be defined.");
        url_ = url_.replace("{roleid}", encodeURIComponent("" + roleid)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersByRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersByRole(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersByRole(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get Manager Users
     * @return OK
     */
    getManagerUsers(): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Participant/GetManagerUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManagerUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManagerUsers(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetManagerUsers(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To Search Company.
     * @return OK
     */
    searchCompany(searchText: string, minSearchChars: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Participant/SearchCompany/{searchText}?";
        if (searchText === undefined || searchText === null)
            throw new Error("The parameter 'searchText' must be defined.");
        url_ = url_.replace("{searchText}", encodeURIComponent("" + searchText)); 
        if (minSearchChars === undefined || minSearchChars === null)
            throw new Error("The parameter 'minSearchChars' must be defined and cannot be null.");
        else
            url_ += "minSearchChars=" + encodeURIComponent("" + minSearchChars) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchCompany(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSearchCompany(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    searchPerson(searchText: string, minSearchChars: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Participant/SearchPerson?";
        if (searchText === undefined || searchText === null)
            throw new Error("The parameter 'searchText' must be defined and cannot be null.");
        else
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&"; 
        if (minSearchChars === undefined || minSearchChars === null)
            throw new Error("The parameter 'minSearchChars' must be defined and cannot be null.");
        else
            url_ += "minSearchChars=" + encodeURIComponent("" + minSearchChars) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchPerson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchPerson(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSearchPerson(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    setParticipantAsPrimary(dealId: number, dealUserId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Participant/SetParticipantAsPrimary/{dealId}/{dealUserId}";
        if (dealId === undefined || dealUserId === null)
            throw new Error("The parameter 'dealId' must be defined and cannot be null.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (dealUserId === undefined || dealUserId === null)
            throw new Error("The parameter 'dealUserId' must be defined and cannot be null.");
        url_ = url_.replace("{dealUserId}", encodeURIComponent("" + dealUserId)); 
            url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetParticipantAsPrimary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetParticipantAsPrimary(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSetParticipantAsPrimary(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
    /**
     * Get persons associated with company.
                <param name="companyId"></param>
     * @return OK
     */
    getPersonsByCompany(companyId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Participant/GetPersonsByCompany/{companyId}";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonsByCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonsByCompany(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetPersonsByCompany(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get UserDeal check for primary
     * @return OK
     */
    getUserDealPrimaryCheck(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Participant/GetUserDealPrimaryCheck/{dealId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDealPrimaryCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDealPrimaryCheck(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDealPrimaryCheck(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get Officers or secondary officeres for deal
     * @return OK
     */
    getOfficersForDeal(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Participant/GetOfficersForDeal/{dealId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOfficersForDeal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOfficersForDeal(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetOfficersForDeal(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get users for dropdown
     * @return OK
     */
    getUsersForDropdown(): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Participant/GetUsersForDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersForDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersForDropdown(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersForDropdown(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * AM : Remove internal participant
     * @return OK
     */
    delete(dealUserId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Participant/Delete/{dealUserId}";
        if (dealUserId === undefined || dealUserId === null)
            throw new Error("The parameter 'dealUserId' must be defined.");
        url_ = url_.replace("{dealUserId}", encodeURIComponent("" + dealUserId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Post a new participant for a deal (DealParticipantDto)
     * @return OK
     */
    post(dealParticipant: DealParticipantDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Participant/Post";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dealParticipant);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    getUserForParticipants(): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Participant/GetUserForParticipants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForParticipants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForParticipants(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForParticipants(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class PartyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * Get Parties associated with deal
     * @return OK
     */
    getPartyListForDeal(dealId: number, type: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/party/GetPartyListForDeal/{dealId}/{type}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartyListForDeal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartyListForDeal(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetPartyListForDeal(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To get party details by dealId and partyId.
     * @return OK
     */
    getPartyDetails(dealId: number, partyId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/party/GetPartyDetails/{dealId}/{partyId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (partyId === undefined || partyId === null)
            throw new Error("The parameter 'partyId' must be defined.");
        url_ = url_.replace("{partyId}", encodeURIComponent("" + partyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartyDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartyDetails(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetPartyDetails(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To check primary borrower for party.
     * @return OK
     */
    getPartyForPrimaryCheck(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/party/GetPartyForPrimaryCheck/{dealId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartyForPrimaryCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartyForPrimaryCheck(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetPartyForPrimaryCheck(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To get filterd party users.
     * @return OK
     */
    getPartyUsers(partyUserSearchFilter: PartyUserSearchFilterCustomModel): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/party/GetPartyUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(partyUserSearchFilter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartyUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartyUsers(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetPartyUsers(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To get parties For Deal.
     * @return OK
     */
    getPartyForDeal(dealId: number, type: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/party/GetPartyForDeal/{dealId}/{type}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartyForDeal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartyForDeal(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetPartyForDeal(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get requirements for party
     * @return OK
     */
    getPartyRequirementsList(dealId: number, partyId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/party/GetPartyRequirementsList/{dealId}/{partyId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (partyId === undefined || partyId === null)
            throw new Error("The parameter 'partyId' must be defined.");
        url_ = url_.replace("{partyId}", encodeURIComponent("" + partyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartyRequirementsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartyRequirementsList(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetPartyRequirementsList(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get documents for party
     * @return OK
     */
    getPartyDocumentsList(dealId: number, partyId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/party/GetPartyDocumentsList/{dealId}/{partyId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (partyId === undefined || partyId === null)
            throw new Error("The parameter 'partyId' must be defined.");
        url_ = url_.replace("{partyId}", encodeURIComponent("" + partyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartyDocumentsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartyDocumentsList(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetPartyDocumentsList(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * SB: Create Party
     * @return OK
     */
    createParty(party: PartyDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/party/CreateParty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(party);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateParty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateParty(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processCreateParty(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Post Party (Save)
     * @return OK
     */
    post(party: PartyDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/party/Post";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(party);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Put - Party (Update)
     * @return OK
     */
    put(party: PartyDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/party/UpdateParty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(party);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Updating party roles
     * @return OK
     */
    savePartyRoles(parties: PartyDto[]): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/party/SavePartyRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(parties);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePartyRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePartyRoles(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSavePartyRoles(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    getRequirementDocumentsForParty(dealId: number, partyId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/party/GetRequirementDocumentsForParty/{dealId}/{partyId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (partyId === undefined || partyId === null)
            throw new Error("The parameter 'partyId' must be defined.");
        url_ = url_.replace("{partyId}", encodeURIComponent("" + partyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequirementDocumentsForParty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequirementDocumentsForParty(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequirementDocumentsForParty(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    saveExternalParticipation(party: PartyDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/party/SaveExternalParticipation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(party);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveExternalParticipation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveExternalParticipation(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSaveExternalParticipation(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Delete party
     * @return OK
     */
    delete(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/Party/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class ProcessStageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * To Get Process Stage Function.
     * @return OK
     */
    getProcessStageFunction(processId: string, stageId: string, userId: string, isException: boolean): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/stage/GetProcessStageFunction/{processId}/{stageId}/{userId}/{isException}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (stageId === undefined || stageId === null)
            throw new Error("The parameter 'stageId' must be defined.");
        url_ = url_.replace("{stageId}", encodeURIComponent("" + stageId)); 
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        if (isException === undefined || isException === null)
            throw new Error("The parameter 'isException' must be defined.");
        url_ = url_.replace("{isException}", encodeURIComponent("" + isException)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessStageFunction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessStageFunction(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessStageFunction(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To Get Process Stage Function User.
     * @return OK
     */
    getProcessStageFunctionUser(processId: string, stageId: string, functionId: string, userId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/stage/GetProcessStageFunctionUser/{processId}/{stageId}/{functionId}/{userId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (stageId === undefined || stageId === null)
            throw new Error("The parameter 'stageId' must be defined.");
        url_ = url_.replace("{stageId}", encodeURIComponent("" + stageId)); 
        if (functionId === undefined || functionId === null)
            throw new Error("The parameter 'functionId' must be defined.");
        url_ = url_.replace("{functionId}", encodeURIComponent("" + functionId)); 
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessStageFunctionUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessStageFunctionUser(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessStageFunctionUser(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To get process stage COFO.
     * @return OK
     */
    getProcessStageCOFO(processId: string, stageId: string, containerId: string, containerObjectId: string, functionId: string, userId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/stage/GetProcessStageCOFO/{processId}/{stageId}/{containerId}/{containerObjectId}/{functionId}/{userId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (stageId === undefined || stageId === null)
            throw new Error("The parameter 'stageId' must be defined.");
        url_ = url_.replace("{stageId}", encodeURIComponent("" + stageId)); 
        if (containerId === undefined || containerId === null)
            throw new Error("The parameter 'containerId' must be defined.");
        url_ = url_.replace("{containerId}", encodeURIComponent("" + containerId)); 
        if (containerObjectId === undefined || containerObjectId === null)
            throw new Error("The parameter 'containerObjectId' must be defined.");
        url_ = url_.replace("{containerObjectId}", encodeURIComponent("" + containerObjectId)); 
        if (functionId === undefined || functionId === null)
            throw new Error("The parameter 'functionId' must be defined.");
        url_ = url_.replace("{functionId}", encodeURIComponent("" + functionId)); 
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessStageCOFO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessStageCOFO(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessStageCOFO(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To get defer to.
     * @return OK
     */
    getDeferTo(requirementId: string, dealId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/stage/GetDeferTo/{requirementId}/{dealId}";
        if (requirementId === undefined || requirementId === null)
            throw new Error("The parameter 'requirementId' must be defined.");
        url_ = url_.replace("{requirementId}", encodeURIComponent("" + requirementId)); 
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeferTo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeferTo(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeferTo(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To get send to stages.
     * @return OK
     */
    getSendToStages(processId: string, stageId: string, userId: string, functionId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/stage/GetSendToStages/{processId}/{stageId}/{userId}/{functionId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (stageId === undefined || stageId === null)
            throw new Error("The parameter 'stageId' must be defined.");
        url_ = url_.replace("{stageId}", encodeURIComponent("" + stageId)); 
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        if (functionId === undefined || functionId === null)
            throw new Error("The parameter 'functionId' must be defined.");
        url_ = url_.replace("{functionId}", encodeURIComponent("" + functionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSendToStages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSendToStages(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetSendToStages(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To GetProcess Stage Function Object.
     * @return OK
     */
    getProcessStageFunctionObject(processId: string, stageId: string, functionId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/stage/GetProcessStageFunctionObject/{processId}/{stageId}/{functionId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (stageId === undefined || stageId === null)
            throw new Error("The parameter 'stageId' must be defined.");
        url_ = url_.replace("{stageId}", encodeURIComponent("" + stageId)); 
        if (functionId === undefined || functionId === null)
            throw new Error("The parameter 'functionId' must be defined.");
        url_ = url_.replace("{functionId}", encodeURIComponent("" + functionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessStageFunctionObject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessStageFunctionObject(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessStageFunctionObject(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To check is next stage  after current  stages.
     * @return OK
     */
    isNextStageAfterCurrentStage(processId: string, currentStageId: string, nextStageId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/stage/IsNextStageAfterCurrentStage/{processId}/{currentStageId}/{nextStageId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (currentStageId === undefined || currentStageId === null)
            throw new Error("The parameter 'currentStageId' must be defined.");
        url_ = url_.replace("{currentStageId}", encodeURIComponent("" + currentStageId)); 
        if (nextStageId === undefined || nextStageId === null)
            throw new Error("The parameter 'nextStageId' must be defined.");
        url_ = url_.replace("{nextStageId}", encodeURIComponent("" + nextStageId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsNextStageAfterCurrentStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsNextStageAfterCurrentStage(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processIsNextStageAfterCurrentStage(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To get stage details.
     * @return OK
     */
    getStageDetail(processId: string, stageId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/stage/GetStageDetail/{processId}/{stageId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (stageId === undefined || stageId === null)
            throw new Error("The parameter 'stageId' must be defined.");
        url_ = url_.replace("{stageId}", encodeURIComponent("" + stageId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStageDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStageDetail(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetStageDetail(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class RabbitMQMessagingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * @return OK
     */
    postMsgToRabbitMQ(queueName: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/RabbitMQ/PostMsgToRabbitMQ/{queueName}";
        if (queueName === undefined || queueName === null)
            throw new Error("The parameter 'queueName' must be defined.");
        url_ = url_.replace("{queueName}", encodeURIComponent("" + queueName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostMsgToRabbitMQ(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostMsgToRabbitMQ(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processPostMsgToRabbitMQ(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * Get report data
     * @return OK
     */
    showReport(queryName: string, dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Report/ShowReport/{queryName}/{dealId}";
        if (queryName === undefined || queryName === null)
            throw new Error("The parameter 'queryName' must be defined.");
        url_ = url_.replace("{queryName}", encodeURIComponent("" + queryName)); 
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowReport(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processShowReport(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Show deals by name
     * @return OK
     */
    showDealsByName(queryName: string, userId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Report/ShowDealsByName/{queryName}/{userId}";
        if (queryName === undefined || queryName === null)
            throw new Error("The parameter 'queryName' must be defined.");
        url_ = url_.replace("{queryName}", encodeURIComponent("" + queryName)); 
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowDealsByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowDealsByName(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processShowDealsByName(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class RequirementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * Get Req associated with deals
     * @param loanRequestType (optional) 
     * @param groupFilter (optional) 
     * @return OK
     */
    getRequirementList(id: number, loanRequestType?: string | null | undefined, groupFilter?: string | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/GetRequirementList/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (loanRequestType !== undefined)
            url_ += "loanRequestType=" + encodeURIComponent("" + loanRequestType) + "&"; 
        if (groupFilter !== undefined)
            url_ += "groupFilter=" + encodeURIComponent("" + groupFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequirementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequirementList(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequirementList(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get details of particular requirement
     * @return OK
     */
    getRequirementDetails(dealid: number, reqid: number, reqType: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/GetReqDetails/{dealid}/{reqid}/{reqType}";
        if (dealid === undefined || dealid === null)
            throw new Error("The parameter 'dealid' must be defined.");
        url_ = url_.replace("{dealid}", encodeURIComponent("" + dealid)); 
        if (reqid === undefined || reqid === null)
            throw new Error("The parameter 'reqid' must be defined.");
        url_ = url_.replace("{reqid}", encodeURIComponent("" + reqid)); 
        if (reqType === undefined || reqType === null)
            throw new Error("The parameter 'reqType' must be defined.");
        url_ = url_.replace("{reqType}", encodeURIComponent("" + reqType)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequirementDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequirementDetails(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequirementDetails(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get Stage history.
     * @return OK
     */
    getStageHistory(processhistoryId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/GetStageHistory/{processhistoryId}";
        if (processhistoryId === undefined || processhistoryId === null)
            throw new Error("The parameter 'processhistoryId' must be defined.");
        url_ = url_.replace("{processhistoryId}", encodeURIComponent("" + processhistoryId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStageHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStageHistory(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetStageHistory(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get requirements due by deal stage
     * @return OK
     */
    getRequirementDueByDealStage(dealId: number, groupCode: string, loanRequestType: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/GetRequirementDueByDealStage/{dealId}/{groupCode}/{loanRequestType}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (groupCode === undefined || groupCode === null)
            throw new Error("The parameter 'groupCode' must be defined.");
        url_ = url_.replace("{groupCode}", encodeURIComponent("" + groupCode)); 
        if (loanRequestType === undefined || loanRequestType === null)
            throw new Error("The parameter 'loanRequestType' must be defined.");
        url_ = url_.replace("{loanRequestType}", encodeURIComponent("" + loanRequestType)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequirementDueByDealStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequirementDueByDealStage(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequirementDueByDealStage(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * OH: Get Documents for Requirement
     * @return OK
     */
    getDocumentsForRequirement(requirementId: number): Observable<DocumentDto[]> {
        let url_ = this.baseUrl + "/api/v1/requirement/GetDocumentsForRequirement/{requirementId}";
        if (requirementId === undefined || requirementId === null)
            throw new Error("The parameter 'requirementId' must be defined.");
        url_ = url_.replace("{requirementId}", encodeURIComponent("" + requirementId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentsForRequirement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentsForRequirement(<any>response_);
                } catch (e) {
                    return <Observable<DocumentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentsForRequirement(response: HttpResponseBase): Observable<DocumentDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentDto[]>(<any>null);
    }

    /**
     * OH: Is Exception
     * @return OK
     */
    checkRequirementException(requirements: RequirementDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/CheckRequirementException";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requirements);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckRequirementException(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckRequirementException(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processCheckRequirementException(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get manual requirement definition
     * @return OK
     */
    getManualRequirementDefinition(reqType: string, user: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/GetManualRequirementDefinition/{reqType}/{user}";
        if (reqType === undefined || reqType === null)
            throw new Error("The parameter 'reqType' must be defined.");
        url_ = url_.replace("{reqType}", encodeURIComponent("" + reqType)); 
        if (user === undefined || user === null)
            throw new Error("The parameter 'user' must be defined.");
        url_ = url_.replace("{user}", encodeURIComponent("" + user)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManualRequirementDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManualRequirementDefinition(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetManualRequirementDefinition(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get requirement by Id
     * @param dealId (optional) 
     * @param entityType (optional) 
     * @return OK
     */
    getRequirementById(requirementId: number, dealId?: number | null | undefined, entityType?: string | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/GetRequirementById/{requirementId}?";
        if (requirementId === undefined || requirementId === null)
            throw new Error("The parameter 'requirementId' must be defined.");
        url_ = url_.replace("{requirementId}", encodeURIComponent("" + requirementId)); 
        if (dealId !== undefined)
            url_ += "dealId=" + encodeURIComponent("" + dealId) + "&"; 
        if (entityType !== undefined)
            url_ += "entityType=" + encodeURIComponent("" + entityType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequirementById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequirementById(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequirementById(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get req entities by dealId
     * @return OK
     */
    getAllRequirementEntities(dealId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/GetAllRequirementEntities/{dealId}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRequirementEntities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRequirementEntities(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRequirementEntities(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Save Questions
     * @return OK
     */
    postQuestions(req: RequirementQuestion): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/PostQuestions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostQuestions(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processPostQuestions(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Save Comments
     * @return OK
     */
    postComments(req: RequirementComment): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/PostComments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostComments(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processPostComments(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    post(req: any): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/Post";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get : To get all questions and related answers for tickler req
     * @return OK
     */
    getQuestionsForTicklerReq(dealid: number, reqid: number, ticklerid: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/GetQuestionsForTicklerReq/{dealid}/{reqid}/{ticklerid}";
        if (dealid === undefined || dealid === null)
            throw new Error("The parameter 'dealid' must be defined.");
        url_ = url_.replace("{dealid}", encodeURIComponent("" + dealid)); 
        if (reqid === undefined || reqid === null)
            throw new Error("The parameter 'reqid' must be defined.");
        url_ = url_.replace("{reqid}", encodeURIComponent("" + reqid)); 
        if (ticklerid === undefined || ticklerid === null)
            throw new Error("The parameter 'ticklerid' must be defined.");
        url_ = url_.replace("{ticklerid}", encodeURIComponent("" + ticklerid)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionsForTicklerReq(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionsForTicklerReq(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestionsForTicklerReq(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get: To get all questions and related answers for base req
     * @return OK
     */
    getQuestionsForBaseReq(dealid: number, reqid: number, reqdefinitionid: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/GetQuestionsForBaseReq/{dealid}/{reqid}/{reqdefinitionid}";
        if (dealid === undefined || dealid === null)
            throw new Error("The parameter 'dealid' must be defined.");
        url_ = url_.replace("{dealid}", encodeURIComponent("" + dealid)); 
        if (reqid === undefined || reqid === null)
            throw new Error("The parameter 'reqid' must be defined.");
        url_ = url_.replace("{reqid}", encodeURIComponent("" + reqid)); 
        if (reqdefinitionid === undefined || reqdefinitionid === null)
            throw new Error("The parameter 'reqdefinitionid' must be defined.");
        url_ = url_.replace("{reqdefinitionid}", encodeURIComponent("" + reqdefinitionid)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionsForBaseReq(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionsForBaseReq(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestionsForBaseReq(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    isException(req: RequirementCustomModel): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/IsException";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsException(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsException(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processIsException(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    checkIsExceptionForTicklerReq(req: ReqTicklerQuestionCustomModel[]): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/CheckIsExceptionForTicklerReq";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIsExceptionForTicklerReq(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIsExceptionForTicklerReq(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processCheckIsExceptionForTicklerReq(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    checkIsExceptionForBaseReq(req: ReqDefinitionQuestionCustomModel[]): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/CheckIsExceptionForBaseReq";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIsExceptionForBaseReq(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIsExceptionForBaseReq(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processCheckIsExceptionForBaseReq(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    requirementListByPage(reqlist: RequirementDto[], pagesize: number, page: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/RequirementListByPage?";
        if (pagesize === undefined || pagesize === null)
            throw new Error("The parameter 'pagesize' must be defined and cannot be null.");
        else
            url_ += "pagesize=" + encodeURIComponent("" + pagesize) + "&"; 
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(reqlist);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequirementListByPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequirementListByPage(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processRequirementListByPage(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get Process Req associated with deals
     * @param loanRequestType (optional) 
     * @param groupFilter (optional) 
     * @return OK
     */
    getProcessRequirementList(id: number, loanRequestType?: string | null | undefined, groupFilter?: string | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/requirement/GetProcessRequirementList/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (loanRequestType !== undefined)
            url_ += "loanRequestType=" + encodeURIComponent("" + loanRequestType) + "&"; 
        if (groupFilter !== undefined)
            url_ += "groupFilter=" + encodeURIComponent("" + groupFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessRequirementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessRequirementList(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessRequirementList(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * @return OK
     */
    get(tenantId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/tenants/Get?";
        if (tenantId === undefined || tenantId === null)
            throw new Error("The parameter 'tenantId' must be defined and cannot be null.");
        else
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Save tenant
     * @return OK
     */
    post(tenant: TenantDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/tenants/Post";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tenant);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get All Tenants
     * @return OK
     */
    getTenants(): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/tenants/GetTenants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * Get user profile
     * @return OK
     */
    getUserProfile(userId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/user/GetUserProfile/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserProfile(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get Start Time and End Time for User Out Of Office
     * @return OK
     */
    getUserOutOfOffice(userId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/user/GetUserOutOfOffice/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserOutOfOffice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserOutOfOffice(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserOutOfOffice(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Method to check particular permission is granted to  logged in user
     * @return OK
     */
    checkIsPermissionGrantedForUser(permissionName: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/user/CheckIsPermissionGrantedForUser?";
        if (permissionName === undefined || permissionName === null)
            throw new Error("The parameter 'permissionName' must be defined and cannot be null.");
        else
            url_ += "permissionName=" + encodeURIComponent("" + permissionName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIsPermissionGrantedForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIsPermissionGrantedForUser(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processCheckIsPermissionGrantedForUser(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get User Full Profile.
     * @return OK
     */
    getUserFullProfile(userId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/user/GetUserFullProfile/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserFullProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserFullProfile(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserFullProfile(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * PK:Set userprofile detail to userFullProfile
     * @return OK
     */
    setUserFullProfile(userModal: UserFullProfileDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/user/SetUserFullProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userModal);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetUserFullProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetUserFullProfile(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSetUserFullProfile(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * SB : Set Start Time and End Time for User Out Of Office
     * @return OK
     */
    setUserOutOfOffice(userModal: UserOutOfOfficeDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/user/SetUserOutOfOffice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userModal);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetUserOutOfOffice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetUserOutOfOffice(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSetUserOutOfOffice(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Get User Roles By ID
     * @return OK
     */
    getUserRoles(userId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/user/GetUserRoles/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRoles(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserRoles(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To get primary role of user.
     * @return OK
     */
    primaryRole(userId: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/user/PrimaryRole/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrimaryRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrimaryRole(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processPrimaryRole(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To get primary participation code.
     * @return OK
     */
    getUserPrimaryParticipationCode(userId: string): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/user/GetUserPrimaryParticipationCode/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPrimaryParticipationCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPrimaryParticipationCode(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPrimaryParticipationCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * To Find user by email address.
     * @return OK
     */
    findUserByEmailAddress(emailAddress: string): Observable<UserFullProfileDto> {
        let url_ = this.baseUrl + "/api/v1/user/FindUserByEmailAddress?";
        if (emailAddress === undefined || emailAddress === null)
            throw new Error("The parameter 'emailAddress' must be defined and cannot be null.");
        else
            url_ += "emailAddress=" + encodeURIComponent("" + emailAddress) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUserByEmailAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUserByEmailAddress(<any>response_);
                } catch (e) {
                    return <Observable<UserFullProfileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserFullProfileDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUserByEmailAddress(response: HttpResponseBase): Observable<UserFullProfileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserFullProfileDto.fromJS(resultData200) : new UserFullProfileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserFullProfileDto>(<any>null);
    }

    /**
     * To Find user preferences.
     * @return OK
     */
    findUserPreferences(userId: string): Observable<UserPreferenceDto[]> {
        let url_ = this.baseUrl + "/api/v1/user/FindUserPreferences/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUserPreferences(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUserPreferences(<any>response_);
                } catch (e) {
                    return <Observable<UserPreferenceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserPreferenceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processFindUserPreferences(response: HttpResponseBase): Observable<UserPreferenceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserPreferenceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserPreferenceDto[]>(<any>null);
    }

    /**
     * To Get user preferences by key.
     * @return OK
     */
    getUserPreferencesByKey(userId: string, key: string): Observable<UserPreferenceDto> {
        let url_ = this.baseUrl + "/api/v1/user/GetUserPreferencesByKey/{userId}/{key}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPreferencesByKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPreferencesByKey(<any>response_);
                } catch (e) {
                    return <Observable<UserPreferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserPreferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPreferencesByKey(response: HttpResponseBase): Observable<UserPreferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserPreferenceDto.fromJS(resultData200) : new UserPreferenceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserPreferenceDto>(<any>null);
    }

    /**
     * To Find user recently visited inboxes.
     * @return OK
     */
    getRecentInboxData(): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/user/GetRecentInboxData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentInboxData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentInboxData(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentInboxData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * To Find user recently visited Deals.
     * @return OK
     */
    getRecentDealData(): Observable<DealDto[]> {
        let url_ = this.baseUrl + "/api/v1/user/GetRecentDealData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentDealData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentDealData(<any>response_);
                } catch (e) {
                    return <Observable<DealDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DealDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentDealData(response: HttpResponseBase): Observable<DealDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DealDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DealDto[]>(<any>null);
    }

    /**
     * To Insert user recently visited inbox.
     * @return OK
     */
    insertUserPreference(userId: string, preferenceCode: string, preference: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/user/InsertUserPreference?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (preferenceCode === undefined || preferenceCode === null)
            throw new Error("The parameter 'preferenceCode' must be defined and cannot be null.");
        else
            url_ += "preferenceCode=" + encodeURIComponent("" + preferenceCode) + "&"; 
        if (preference === undefined || preference === null)
            throw new Error("The parameter 'preference' must be defined and cannot be null.");
        else
            url_ += "preference=" + encodeURIComponent("" + preference) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUserPreference(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUserPreference(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processInsertUserPreference(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * get user role base on "UserProfileMgmtRoles"
     * @return OK
     */
    getLaAssistantUserRole(): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/user/GetLaAssistantUserRole";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLaAssistantUserRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLaAssistantUserRole(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetLaAssistantUserRole(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    getUserProfileImageUrl(): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/user/GetUserProfileImageUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserProfileImageUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProfileImageUrl(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserProfileImageUrl(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class ValuesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * GET apl/values
     * @return OK
     */
    getAll(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/v1/Values/GetValues";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * Get Parameter
     * @return OK
     */
    get(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/Values/GetParameter?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Values/GetCOMonitor
     * @return OK
     */
    getCoMonitor(): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Values/getCoMonitor";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoMonitor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoMonitor(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetCoMonitor(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Values/GetCoPermissions
     * @return OK
     */
    getCoPermissions(): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Values/getCoPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoPermissions(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetCoPermissions(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Values/GetUserPermissions
     * @return OK
     */
    getUserPermissions(userid: string): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Values/getUserPermissions?";
        if (userid === undefined || userid === null)
            throw new Error("The parameter 'userid' must be defined and cannot be null.");
        else
            url_ += "userid=" + encodeURIComponent("" + userid) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissions(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPermissions(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * POST Values/CreatePSRolePermissions
     * @return No Content
     */
    createPSRolePermission(permission: CoPermission): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Values/post";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(permission);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePSRolePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePSRolePermission(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePSRolePermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return No Content
     */
    post(value: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Values";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return No Content
     */
    put(id: number, value: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Values/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return No Content
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Values/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WorkFlowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * @return OK
     */
    updateWorkFlow(workFlowRequestDto: WorkFlowRequestDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/WorkFlow/UpdateWorkFlow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(workFlowRequestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWorkFlow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWorkFlow(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateWorkFlow(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Gets the required fields for Loan
                TODO : Check from SP which all parameters are mandatory. Currently testing with processHistoryId etc...
     * @return OK
     */
    getRequiredFieldsForLoan(workFlowRequestDto: WorkFlowRequestDto): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/WorkFlow/GetRequiredFieldsForLoan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(workFlowRequestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequiredFieldsForLoan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequiredFieldsForLoan(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequiredFieldsForLoan(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class DealMessagesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }

    /**
     * Get announcements to show on home tab
     * @return OK
     */
    getDealMessages(dealId: number, pageSize: number, page: number): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/GetDealMessages/{dealId}/{page}/{pageSize}";
        if (dealId === undefined || dealId === null)
            throw new Error("The parameter 'dealId' must be defined.");
        url_ = url_.replace("{dealId}", encodeURIComponent("" + dealId)); 
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined.");
        url_ = url_.replace("{page}", encodeURIComponent("" + page)); 
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDealMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDealMessages(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDealMessages(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}


@Injectable()
export class EditMessagesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:58386";
    }
    updateMessage(e: any): Observable<any> {
        return this.http.post<any>(this.baseUrl + '/api/v1/Messaging/EditMessage', e);
      }
    /**
     * Get announcements to show on home tab
     * @return OK
     */
    editMessage(e: any): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Messaging/EditMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(e);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditMessages(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }
    protected processEditMessages(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

export class CollateralDto implements ICollateralDto {
    collateralId?: number | undefined;
    loanId?: number | undefined;
    dealId?: number | undefined;
    category?: string | undefined;
    categoryId?: string | undefined;
    owners?: number[] | undefined;
    description?: string | undefined;
    loans?: number[] | undefined;
    loanLienPosition?: string[] | undefined;
    groupCode?: string | undefined;
    group?: string | undefined;
    primary?: boolean | undefined;
    openRequirements?: number | undefined;
    appraisalType?: string | undefined;
    lienPosition?: string | undefined;
    appraisalStatus?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByDate?: string | undefined;
    estimatedValue?: number | undefined;
    actualValue?: number | undefined;
    vinSerialNum?: string | undefined;
    appraisalDate?: string | undefined;
    subjectProperty?: string | undefined;
    notes?: string | undefined;
    propertyStreetAddress1?: string | undefined;
    propertyStreetAddress2?: string | undefined;
    propertyCity?: string | undefined;
    propertyState?: string | undefined;
    propertyZip?: string | undefined;
    propertyCounty?: string | undefined;

    constructor(data?: ICollateralDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.collateralId = data["collateralId"];
            this.loanId = data["loanId"];
            this.dealId = data["dealId"];
            this.category = data["category"];
            this.categoryId = data["categoryId"];
            if (data["owners"] && data["owners"].constructor === Array) {
                this.owners = [];
                for (let item of data["owners"])
                    this.owners.push(item);
            }
            this.description = data["description"];
            if (data["loans"] && data["loans"].constructor === Array) {
                this.loans = [];
                for (let item of data["loans"])
                    this.loans.push(item);
            }
            if (data["loanLienPosition"] && data["loanLienPosition"].constructor === Array) {
                this.loanLienPosition = [];
                for (let item of data["loanLienPosition"])
                    this.loanLienPosition.push(item);
            }
            this.groupCode = data["groupCode"];
            this.group = data["group"];
            this.primary = data["primary"];
            this.openRequirements = data["openRequirements"];
            this.appraisalType = data["appraisalType"];
            this.lienPosition = data["lienPosition"];
            this.appraisalStatus = data["appraisalStatus"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"];
            this.lastModBy = data["lastModBy"];
            this.lastModByDate = data["lastModByDate"];
            this.estimatedValue = data["estimatedValue"];
            this.actualValue = data["actualValue"];
            this.vinSerialNum = data["vinSerialNum"];
            this.appraisalDate = data["appraisalDate"];
            this.subjectProperty = data["subjectProperty"];
            this.notes = data["notes"];
            this.propertyStreetAddress1 = data["propertyStreetAddress1"];
            this.propertyStreetAddress2 = data["propertyStreetAddress2"];
            this.propertyCity = data["propertyCity"];
            this.propertyState = data["propertyState"];
            this.propertyZip = data["propertyZip"];
            this.propertyCounty = data["propertyCounty"];
        }
    }

    static fromJS(data: any): CollateralDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollateralDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collateralId"] = this.collateralId;
        data["loanId"] = this.loanId;
        data["dealId"] = this.dealId;
        data["category"] = this.category;
        data["categoryId"] = this.categoryId;
        if (this.owners && this.owners.constructor === Array) {
            data["owners"] = [];
            for (let item of this.owners)
                data["owners"].push(item);
        }
        data["description"] = this.description;
        if (this.loans && this.loans.constructor === Array) {
            data["loans"] = [];
            for (let item of this.loans)
                data["loans"].push(item);
        }
        if (this.loanLienPosition && this.loanLienPosition.constructor === Array) {
            data["loanLienPosition"] = [];
            for (let item of this.loanLienPosition)
                data["loanLienPosition"].push(item);
        }
        data["groupCode"] = this.groupCode;
        data["group"] = this.group;
        data["primary"] = this.primary;
        data["openRequirements"] = this.openRequirements;
        data["appraisalType"] = this.appraisalType;
        data["lienPosition"] = this.lienPosition;
        data["appraisalStatus"] = this.appraisalStatus;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate;
        data["lastModBy"] = this.lastModBy;
        data["lastModByDate"] = this.lastModByDate;
        data["estimatedValue"] = this.estimatedValue;
        data["actualValue"] = this.actualValue;
        data["vinSerialNum"] = this.vinSerialNum;
        data["appraisalDate"] = this.appraisalDate;
        data["subjectProperty"] = this.subjectProperty;
        data["notes"] = this.notes;
        data["propertyStreetAddress1"] = this.propertyStreetAddress1;
        data["propertyStreetAddress2"] = this.propertyStreetAddress2;
        data["propertyCity"] = this.propertyCity;
        data["propertyState"] = this.propertyState;
        data["propertyZip"] = this.propertyZip;
        data["propertyCounty"] = this.propertyCounty;
        return data; 
    }
}

export interface ICollateralDto {
    collateralId?: number | undefined;
    loanId?: number | undefined;
    dealId?: number | undefined;
    category?: string | undefined;
    categoryId?: string | undefined;
    owners?: number[] | undefined;
    description?: string | undefined;
    loans?: number[] | undefined;
    loanLienPosition?: string[] | undefined;
    groupCode?: string | undefined;
    group?: string | undefined;
    primary?: boolean | undefined;
    openRequirements?: number | undefined;
    appraisalType?: string | undefined;
    lienPosition?: string | undefined;
    appraisalStatus?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByDate?: string | undefined;
    estimatedValue?: number | undefined;
    actualValue?: number | undefined;
    vinSerialNum?: string | undefined;
    appraisalDate?: string | undefined;
    subjectProperty?: string | undefined;
    notes?: string | undefined;
    propertyStreetAddress1?: string | undefined;
    propertyStreetAddress2?: string | undefined;
    propertyCity?: string | undefined;
    propertyState?: string | undefined;
    propertyZip?: string | undefined;
    propertyCounty?: string | undefined;
}

export class DealUserNoteCustomModel implements IDealUserNoteCustomModel {
    dealUserNoteId?: number | undefined;
    dealId?: number | undefined;
    userId?: string | undefined;
    note?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByDate?: string | undefined;
    participationCode?: string | undefined;
    lastModByName?: string | undefined;
    role?: string | undefined;

    constructor(data?: IDealUserNoteCustomModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dealUserNoteId = data["dealUserNoteId"];
            this.dealId = data["dealId"];
            this.userId = data["userId"];
            this.note = data["note"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"];
            this.lastModBy = data["lastModBy"];
            this.lastModByDate = data["lastModByDate"];
            this.participationCode = data["participationCode"];
            this.lastModByName = data["lastModByName"];
            this.role = data["role"];
        }
    }

    static fromJS(data: any): DealUserNoteCustomModel {
        data = typeof data === 'object' ? data : {};
        let result = new DealUserNoteCustomModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dealUserNoteId"] = this.dealUserNoteId;
        data["dealId"] = this.dealId;
        data["userId"] = this.userId;
        data["note"] = this.note;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate;
        data["lastModBy"] = this.lastModBy;
        data["lastModByDate"] = this.lastModByDate;
        data["participationCode"] = this.participationCode;
        data["lastModByName"] = this.lastModByName;
        data["role"] = this.role;
        return data; 
    }
}

export interface IDealUserNoteCustomModel {
    dealUserNoteId?: number | undefined;
    dealId?: number | undefined;
    userId?: string | undefined;
    note?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByDate?: string | undefined;
    participationCode?: string | undefined;
    lastModByName?: string | undefined;
    role?: string | undefined;
}

export class DocumentCustomModel implements IDocumentCustomModel {
    id?: number | undefined;
    documentDefinitionId?: number | undefined;
    documentDefinitionName?: string | undefined;
    file?: string | undefined;
    name?: string | undefined;
    alternateName?: string | undefined;
    description?: string | undefined;
    recievedDate?: string | undefined;
    asOfDate?: string | undefined;
    expirationDate?: string | undefined;
    uploadDate?: string | undefined;
    primary?: boolean | undefined;
    notes?: string | undefined;
    isIIS?: boolean | undefined;
    dealId?: number | undefined;
    requirementId?: number | undefined;
    mimeType?: string | undefined;
    fileGuid?: string | undefined;
    requirementAttachmentCount?: number | undefined;
    attachedRequirements?: RequirementCustomModel[] | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByFirstname?: string | undefined;
    lastModByLastname?: string | undefined;
    lastModByDate?: string | undefined;
    ecmExportReady?: boolean | undefined;
    ecmExported?: boolean | undefined;
    ecmCabinetCode?: string | undefined;
    ecmFileName?: string | undefined;
    ecmExportedBy?: string | undefined;
    ecmExportedDate?: string | undefined;
    ecmUploadEnabled?: boolean | undefined;
    active?: boolean | undefined;
    setAsOfDate?: boolean | undefined;
    entityIds?: number[] | undefined;
    entityType?: string | undefined;
    requirementAttachDate?: string | undefined;
    docDefinitionCode?: string | undefined;
    createdByFirstname?: string | undefined;
    createdByLastname?: string | undefined;

    constructor(data?: IDocumentCustomModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.documentDefinitionId = data["documentDefinitionId"];
            this.documentDefinitionName = data["documentDefinitionName"];
            this.file = data["file"];
            this.name = data["name"];
            this.alternateName = data["alternateName"];
            this.description = data["description"];
            this.recievedDate = data["recievedDate"];
            this.asOfDate = data["asOfDate"];
            this.expirationDate = data["expirationDate"];
            this.uploadDate = data["uploadDate"];
            this.primary = data["primary"];
            this.notes = data["notes"];
            this.isIIS = data["isIIS"];
            this.dealId = data["dealId"];
            this.requirementId = data["requirementId"];
            this.mimeType = data["mimeType"];
            this.fileGuid = data["fileGuid"];
            this.requirementAttachmentCount = data["requirementAttachmentCount"];
            if (data["attachedRequirements"] && data["attachedRequirements"].constructor === Array) {
                this.attachedRequirements = [];
                for (let item of data["attachedRequirements"])
                    this.attachedRequirements.push(RequirementCustomModel.fromJS(item));
            }
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"];
            this.lastModBy = data["lastModBy"];
            this.lastModByFirstname = data["lastModByFirstname"];
            this.lastModByLastname = data["lastModByLastname"];
            this.lastModByDate = data["lastModByDate"];
            this.ecmExportReady = data["ecmExportReady"];
            this.ecmExported = data["ecmExported"];
            this.ecmCabinetCode = data["ecmCabinetCode"];
            this.ecmFileName = data["ecmFileName"];
            this.ecmExportedBy = data["ecmExportedBy"];
            this.ecmExportedDate = data["ecmExportedDate"];
            this.ecmUploadEnabled = data["ecmUploadEnabled"];
            this.active = data["active"];
            this.setAsOfDate = data["setAsOfDate"];
            if (data["entityIds"] && data["entityIds"].constructor === Array) {
                this.entityIds = [];
                for (let item of data["entityIds"])
                    this.entityIds.push(item);
            }
            this.entityType = data["entityType"];
            this.requirementAttachDate = data["requirementAttachDate"];
            this.docDefinitionCode = data["docDefinitionCode"];
            this.createdByFirstname = data["createdByFirstname"];
            this.createdByLastname = data["createdByLastname"];
        }
    }

    static fromJS(data: any): DocumentCustomModel {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentCustomModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentDefinitionId"] = this.documentDefinitionId;
        data["documentDefinitionName"] = this.documentDefinitionName;
        data["file"] = this.file;
        data["name"] = this.name;
        data["alternateName"] = this.alternateName;
        data["description"] = this.description;
        data["recievedDate"] = this.recievedDate;
        data["asOfDate"] = this.asOfDate;
        data["expirationDate"] = this.expirationDate;
        data["uploadDate"] = this.uploadDate;
        data["primary"] = this.primary;
        data["notes"] = this.notes;
        data["isIIS"] = this.isIIS;
        data["dealId"] = this.dealId;
        data["requirementId"] = this.requirementId;
        data["mimeType"] = this.mimeType;
        data["fileGuid"] = this.fileGuid;
        data["requirementAttachmentCount"] = this.requirementAttachmentCount;
        if (this.attachedRequirements && this.attachedRequirements.constructor === Array) {
            data["attachedRequirements"] = [];
            for (let item of this.attachedRequirements)
                data["attachedRequirements"].push(item.toJSON());
        }
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate;
        data["lastModBy"] = this.lastModBy;
        data["lastModByFirstname"] = this.lastModByFirstname;
        data["lastModByLastname"] = this.lastModByLastname;
        data["lastModByDate"] = this.lastModByDate;
        data["ecmExportReady"] = this.ecmExportReady;
        data["ecmExported"] = this.ecmExported;
        data["ecmCabinetCode"] = this.ecmCabinetCode;
        data["ecmFileName"] = this.ecmFileName;
        data["ecmExportedBy"] = this.ecmExportedBy;
        data["ecmExportedDate"] = this.ecmExportedDate;
        data["ecmUploadEnabled"] = this.ecmUploadEnabled;
        data["active"] = this.active;
        data["setAsOfDate"] = this.setAsOfDate;
        if (this.entityIds && this.entityIds.constructor === Array) {
            data["entityIds"] = [];
            for (let item of this.entityIds)
                data["entityIds"].push(item);
        }
        data["entityType"] = this.entityType;
        data["requirementAttachDate"] = this.requirementAttachDate;
        data["docDefinitionCode"] = this.docDefinitionCode;
        data["createdByFirstname"] = this.createdByFirstname;
        data["createdByLastname"] = this.createdByLastname;
        return data; 
    }
}

export interface IDocumentCustomModel {
    id?: number | undefined;
    documentDefinitionId?: number | undefined;
    documentDefinitionName?: string | undefined;
    file?: string | undefined;
    name?: string | undefined;
    alternateName?: string | undefined;
    description?: string | undefined;
    recievedDate?: string | undefined;
    asOfDate?: string | undefined;
    expirationDate?: string | undefined;
    uploadDate?: string | undefined;
    primary?: boolean | undefined;
    notes?: string | undefined;
    isIIS?: boolean | undefined;
    dealId?: number | undefined;
    requirementId?: number | undefined;
    mimeType?: string | undefined;
    fileGuid?: string | undefined;
    requirementAttachmentCount?: number | undefined;
    attachedRequirements?: RequirementCustomModel[] | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByFirstname?: string | undefined;
    lastModByLastname?: string | undefined;
    lastModByDate?: string | undefined;
    ecmExportReady?: boolean | undefined;
    ecmExported?: boolean | undefined;
    ecmCabinetCode?: string | undefined;
    ecmFileName?: string | undefined;
    ecmExportedBy?: string | undefined;
    ecmExportedDate?: string | undefined;
    ecmUploadEnabled?: boolean | undefined;
    active?: boolean | undefined;
    setAsOfDate?: boolean | undefined;
    entityIds?: number[] | undefined;
    entityType?: string | undefined;
    requirementAttachDate?: string | undefined;
    docDefinitionCode?: string | undefined;
    createdByFirstname?: string | undefined;
    createdByLastname?: string | undefined;
}

export class RequirementCustomModel implements IRequirementCustomModel {
    requirementId?: number | undefined;
    reqDefinitionId?: number | undefined;
    reqDealId?: number | undefined;
    requirementDealId?: number | undefined;
    documentDefinitionId?: number | undefined;
    documentDefinitionName?: string | undefined;
    documents?: DocumentCustomModel[] | undefined;
    ticklerReqQuestions?: ReqTicklerQuestionCustomModel[] | undefined;
    baseReqQuestions?: ReqDefinitionQuestionCustomModel[] | undefined;
    documentId?: number | undefined;
    primaryDocumentName?: string | undefined;
    statusDescription?: string | undefined;
    status?: string | undefined;
    description?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    reqType?: string | undefined;
    reqNameId?: string | undefined;
    typeCode?: string | undefined;
    valueLabel?: string | undefined;
    compareFlag?: string | undefined;
    showCompareFlag?: string | undefined;
    expectedValue?: string | undefined;
    actualValue?: string | undefined;
    actualValueEnabled?: boolean | undefined;
    active?: boolean | undefined;
    manualRequirement?: boolean | undefined;
    dueDate?: string | undefined;
    asOfDate?: string | undefined;
    expirationDate?: string | undefined;
    sourceCode?: string | undefined;
    source?: string | undefined;
    entityType?: string | undefined;
    initiateProcessId?: string | undefined;
    processHistoryId?: number | undefined;
    processId?: string | undefined;
    stageId?: string | undefined;
    functionId?: string | undefined;
    processStageFunctionId?: number | undefined;
    deferStageName?: string | undefined;
    stageName?: string | undefined;
    stageStatus?: string | undefined;
    assignedTo?: string | undefined;
    assignedToFullName?: string | undefined;
    createdBy?: string | undefined;
    deferToStage?: string | undefined;
    comment?: string | undefined;
    compareDataType?: string | undefined;
    compareFunctionName?: string | undefined;
    exception?: boolean | undefined;
    complete?: boolean | undefined;
    daysDue?: number | undefined;
    group?: string | undefined;
    requireDocument?: boolean | undefined;
    missingDocument?: boolean | undefined;
    requireAsOfDate?: boolean | undefined;
    expirationPeriodDays?: number | undefined;
    priority?: number | undefined;
    exceptionFlag?: boolean | undefined;
    mitigatingFactors?: string | undefined;
    stageType?: string | undefined;
    isAttention?: boolean | undefined;
    attentionType?: string | undefined;
    actionType?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByDate?: string | undefined;
    apReqNeededforclosing?: boolean | undefined;
    coProcessNeededforclosing?: boolean | undefined;
    isSubjectTo?: boolean | undefined;
    isMitigatingFactors?: boolean | undefined;
    isTickler?: boolean | undefined;
    ticklerDefinitionId?: number | undefined;
    subjectTo?: string | undefined;
    loanRequestType?: string | undefined;
    dealId?: number | undefined;
    isSaveComplete?: boolean | undefined;
    lastModbyFirstname?: string | undefined;
    lastModbyLastname?: string | undefined;
    documentCount?: number | undefined;
    hardstop?: boolean | undefined;
    statusType?: string | undefined;
    frequentlyUsed?: number | undefined;
    displayValue?: string | undefined;
    threadId?: number | undefined;
    threadName?: string | undefined;
    isProcessPortlet?: boolean | undefined;

    constructor(data?: IRequirementCustomModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requirementId = data["requirementId"];
            this.reqDefinitionId = data["reqDefinitionId"];
            this.reqDealId = data["reqDealId"];
            this.requirementDealId = data["requirementDealId"];
            this.documentDefinitionId = data["documentDefinitionId"];
            this.documentDefinitionName = data["documentDefinitionName"];
            if (data["documents"] && data["documents"].constructor === Array) {
                this.documents = [];
                for (let item of data["documents"])
                    this.documents.push(DocumentCustomModel.fromJS(item));
            }
            if (data["ticklerReqQuestions"] && data["ticklerReqQuestions"].constructor === Array) {
                this.ticklerReqQuestions = [];
                for (let item of data["ticklerReqQuestions"])
                    this.ticklerReqQuestions.push(ReqTicklerQuestionCustomModel.fromJS(item));
            }
            if (data["baseReqQuestions"] && data["baseReqQuestions"].constructor === Array) {
                this.baseReqQuestions = [];
                for (let item of data["baseReqQuestions"])
                    this.baseReqQuestions.push(ReqDefinitionQuestionCustomModel.fromJS(item));
            }
            this.documentId = data["documentId"];
            this.primaryDocumentName = data["primaryDocumentName"];
            this.statusDescription = data["statusDescription"];
            this.status = data["status"];
            this.description = data["description"];
            this.name = data["name"];
            this.type = data["type"];
            this.reqType = data["reqType"];
            this.reqNameId = data["reqNameId"];
            this.typeCode = data["typeCode"];
            this.valueLabel = data["valueLabel"];
            this.compareFlag = data["compareFlag"];
            this.showCompareFlag = data["showCompareFlag"];
            this.expectedValue = data["expectedValue"];
            this.actualValue = data["actualValue"];
            this.actualValueEnabled = data["actualValueEnabled"];
            this.active = data["active"];
            this.manualRequirement = data["manualRequirement"];
            this.dueDate = data["dueDate"];
            this.asOfDate = data["asOfDate"];
            this.expirationDate = data["expirationDate"];
            this.sourceCode = data["sourceCode"];
            this.source = data["source"];
            this.entityType = data["entityType"];
            this.initiateProcessId = data["initiateProcessId"];
            this.processHistoryId = data["processHistoryId"];
            this.processId = data["processId"];
            this.stageId = data["stageId"];
            this.functionId = data["functionId"];
            this.processStageFunctionId = data["processStageFunctionId"];
            this.deferStageName = data["deferStageName"];
            this.stageName = data["stageName"];
            this.stageStatus = data["stageStatus"];
            this.assignedTo = data["assignedTo"];
            this.assignedToFullName = data["assignedToFullName"];
            this.createdBy = data["createdBy"];
            this.deferToStage = data["deferToStage"];
            this.comment = data["comment"];
            this.compareDataType = data["compareDataType"];
            this.compareFunctionName = data["compareFunctionName"];
            this.exception = data["exception"];
            this.complete = data["complete"];
            this.daysDue = data["daysDue"];
            this.group = data["group"];
            this.requireDocument = data["requireDocument"];
            this.missingDocument = data["missingDocument"];
            this.requireAsOfDate = data["requireAsOfDate"];
            this.expirationPeriodDays = data["expirationPeriodDays"];
            this.priority = data["priority"];
            this.exceptionFlag = data["exceptionFlag"];
            this.mitigatingFactors = data["mitigatingFactors"];
            this.stageType = data["stageType"];
            this.isAttention = data["isAttention"];
            this.attentionType = data["attentionType"];
            this.actionType = data["actionType"];
            this.createdDate = data["createdDate"];
            this.lastModBy = data["lastModBy"];
            this.lastModByDate = data["lastModByDate"];
            this.apReqNeededforclosing = data["apReqNeededforclosing"];
            this.coProcessNeededforclosing = data["coProcessNeededforclosing"];
            this.isSubjectTo = data["isSubjectTo"];
            this.isMitigatingFactors = data["isMitigatingFactors"];
            this.isTickler = data["isTickler"];
            this.ticklerDefinitionId = data["ticklerDefinitionId"];
            this.subjectTo = data["subjectTo"];
            this.loanRequestType = data["loanRequestType"];
            this.dealId = data["dealId"];
            this.isSaveComplete = data["isSaveComplete"];
            this.lastModbyFirstname = data["lastModbyFirstname"];
            this.lastModbyLastname = data["lastModbyLastname"];
            this.documentCount = data["documentCount"];
            this.hardstop = data["hardstop"];
            this.statusType = data["statusType"];
            this.frequentlyUsed = data["frequentlyUsed"];
            this.displayValue = data["displayValue"];
            this.threadId = data["threadId"];
            this.threadName = data["threadName"];
            this.isProcessPortlet = data["isProcessPortlet"];
        }
    }

    static fromJS(data: any): RequirementCustomModel {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementCustomModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requirementId"] = this.requirementId;
        data["reqDefinitionId"] = this.reqDefinitionId;
        data["reqDealId"] = this.reqDealId;
        data["requirementDealId"] = this.requirementDealId;
        data["documentDefinitionId"] = this.documentDefinitionId;
        data["documentDefinitionName"] = this.documentDefinitionName;
        if (this.documents && this.documents.constructor === Array) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        if (this.ticklerReqQuestions && this.ticklerReqQuestions.constructor === Array) {
            data["ticklerReqQuestions"] = [];
            for (let item of this.ticklerReqQuestions)
                data["ticklerReqQuestions"].push(item.toJSON());
        }
        if (this.baseReqQuestions && this.baseReqQuestions.constructor === Array) {
            data["baseReqQuestions"] = [];
            for (let item of this.baseReqQuestions)
                data["baseReqQuestions"].push(item.toJSON());
        }
        data["documentId"] = this.documentId;
        data["primaryDocumentName"] = this.primaryDocumentName;
        data["statusDescription"] = this.statusDescription;
        data["status"] = this.status;
        data["description"] = this.description;
        data["name"] = this.name;
        data["type"] = this.type;
        data["reqType"] = this.reqType;
        data["reqNameId"] = this.reqNameId;
        data["typeCode"] = this.typeCode;
        data["valueLabel"] = this.valueLabel;
        data["compareFlag"] = this.compareFlag;
        data["showCompareFlag"] = this.showCompareFlag;
        data["expectedValue"] = this.expectedValue;
        data["actualValue"] = this.actualValue;
        data["actualValueEnabled"] = this.actualValueEnabled;
        data["active"] = this.active;
        data["manualRequirement"] = this.manualRequirement;
        data["dueDate"] = this.dueDate;
        data["asOfDate"] = this.asOfDate;
        data["expirationDate"] = this.expirationDate;
        data["sourceCode"] = this.sourceCode;
        data["source"] = this.source;
        data["entityType"] = this.entityType;
        data["initiateProcessId"] = this.initiateProcessId;
        data["processHistoryId"] = this.processHistoryId;
        data["processId"] = this.processId;
        data["stageId"] = this.stageId;
        data["functionId"] = this.functionId;
        data["processStageFunctionId"] = this.processStageFunctionId;
        data["deferStageName"] = this.deferStageName;
        data["stageName"] = this.stageName;
        data["stageStatus"] = this.stageStatus;
        data["assignedTo"] = this.assignedTo;
        data["assignedToFullName"] = this.assignedToFullName;
        data["createdBy"] = this.createdBy;
        data["deferToStage"] = this.deferToStage;
        data["comment"] = this.comment;
        data["compareDataType"] = this.compareDataType;
        data["compareFunctionName"] = this.compareFunctionName;
        data["exception"] = this.exception;
        data["complete"] = this.complete;
        data["daysDue"] = this.daysDue;
        data["group"] = this.group;
        data["requireDocument"] = this.requireDocument;
        data["missingDocument"] = this.missingDocument;
        data["requireAsOfDate"] = this.requireAsOfDate;
        data["expirationPeriodDays"] = this.expirationPeriodDays;
        data["priority"] = this.priority;
        data["exceptionFlag"] = this.exceptionFlag;
        data["mitigatingFactors"] = this.mitigatingFactors;
        data["stageType"] = this.stageType;
        data["isAttention"] = this.isAttention;
        data["attentionType"] = this.attentionType;
        data["actionType"] = this.actionType;
        data["createdDate"] = this.createdDate;
        data["lastModBy"] = this.lastModBy;
        data["lastModByDate"] = this.lastModByDate;
        data["apReqNeededforclosing"] = this.apReqNeededforclosing;
        data["coProcessNeededforclosing"] = this.coProcessNeededforclosing;
        data["isSubjectTo"] = this.isSubjectTo;
        data["isMitigatingFactors"] = this.isMitigatingFactors;
        data["isTickler"] = this.isTickler;
        data["ticklerDefinitionId"] = this.ticklerDefinitionId;
        data["subjectTo"] = this.subjectTo;
        data["loanRequestType"] = this.loanRequestType;
        data["dealId"] = this.dealId;
        data["isSaveComplete"] = this.isSaveComplete;
        data["lastModbyFirstname"] = this.lastModbyFirstname;
        data["lastModbyLastname"] = this.lastModbyLastname;
        data["documentCount"] = this.documentCount;
        data["hardstop"] = this.hardstop;
        data["statusType"] = this.statusType;
        data["frequentlyUsed"] = this.frequentlyUsed;
        data["displayValue"] = this.displayValue;
        data["threadId"] = this.threadId;
        data["threadName"] = this.threadName;
        data["isProcessPortlet"] = this.isProcessPortlet;
        return data; 
    }
}

export interface IRequirementCustomModel {
    requirementId?: number | undefined;
    reqDefinitionId?: number | undefined;
    reqDealId?: number | undefined;
    requirementDealId?: number | undefined;
    documentDefinitionId?: number | undefined;
    documentDefinitionName?: string | undefined;
    documents?: DocumentCustomModel[] | undefined;
    ticklerReqQuestions?: ReqTicklerQuestionCustomModel[] | undefined;
    baseReqQuestions?: ReqDefinitionQuestionCustomModel[] | undefined;
    documentId?: number | undefined;
    primaryDocumentName?: string | undefined;
    statusDescription?: string | undefined;
    status?: string | undefined;
    description?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    reqType?: string | undefined;
    reqNameId?: string | undefined;
    typeCode?: string | undefined;
    valueLabel?: string | undefined;
    compareFlag?: string | undefined;
    showCompareFlag?: string | undefined;
    expectedValue?: string | undefined;
    actualValue?: string | undefined;
    actualValueEnabled?: boolean | undefined;
    active?: boolean | undefined;
    manualRequirement?: boolean | undefined;
    dueDate?: string | undefined;
    asOfDate?: string | undefined;
    expirationDate?: string | undefined;
    sourceCode?: string | undefined;
    source?: string | undefined;
    entityType?: string | undefined;
    initiateProcessId?: string | undefined;
    processHistoryId?: number | undefined;
    processId?: string | undefined;
    stageId?: string | undefined;
    functionId?: string | undefined;
    processStageFunctionId?: number | undefined;
    deferStageName?: string | undefined;
    stageName?: string | undefined;
    stageStatus?: string | undefined;
    assignedTo?: string | undefined;
    assignedToFullName?: string | undefined;
    createdBy?: string | undefined;
    deferToStage?: string | undefined;
    comment?: string | undefined;
    compareDataType?: string | undefined;
    compareFunctionName?: string | undefined;
    exception?: boolean | undefined;
    complete?: boolean | undefined;
    daysDue?: number | undefined;
    group?: string | undefined;
    requireDocument?: boolean | undefined;
    missingDocument?: boolean | undefined;
    requireAsOfDate?: boolean | undefined;
    expirationPeriodDays?: number | undefined;
    priority?: number | undefined;
    exceptionFlag?: boolean | undefined;
    mitigatingFactors?: string | undefined;
    stageType?: string | undefined;
    isAttention?: boolean | undefined;
    attentionType?: string | undefined;
    actionType?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByDate?: string | undefined;
    apReqNeededforclosing?: boolean | undefined;
    coProcessNeededforclosing?: boolean | undefined;
    isSubjectTo?: boolean | undefined;
    isMitigatingFactors?: boolean | undefined;
    isTickler?: boolean | undefined;
    ticklerDefinitionId?: number | undefined;
    subjectTo?: string | undefined;
    loanRequestType?: string | undefined;
    dealId?: number | undefined;
    isSaveComplete?: boolean | undefined;
    lastModbyFirstname?: string | undefined;
    lastModbyLastname?: string | undefined;
    documentCount?: number | undefined;
    hardstop?: boolean | undefined;
    statusType?: string | undefined;
    frequentlyUsed?: number | undefined;
    displayValue?: string | undefined;
    threadId?: number | undefined;
    threadName?: string | undefined;
    isProcessPortlet?: boolean | undefined;
}

export class ReqTicklerQuestionCustomModel implements IReqTicklerQuestionCustomModel {
    reqQuestionCovenantId?: number | undefined;
    reqQuestionDefinitionId?: number | undefined;
    ticklerDefinitionID?: number | undefined;
    requirementID?: number | undefined;
    reqQuestionResultCovenantId?: number | undefined;
    questionDefinitionType?: string | undefined;
    descriptionNotes?: string | undefined;
    questionName?: string | undefined;
    questionText?: string | undefined;
    dataType?: string | undefined;
    actualDate?: string | undefined;
    actualBitValue?: boolean | undefined;
    actualText?: string | undefined;
    actualIntValue?: number | undefined;
    actualDecimalValue?: number | undefined;
    expectedValueDate?: string | undefined;
    expectedValueDateOperand?: string | undefined;
    expectedValueHighDate?: string | undefined;
    expectedValueHighDateOperand?: string | undefined;
    expectedValueBit?: boolean | undefined;
    expectedValueInt?: number | undefined;
    expectedValueDecimal?: number | undefined;
    expectedValueVarchar?: string | undefined;
    expectedValueLowOperand?: string | undefined;
    expectedValueHigh?: number | undefined;
    expectedValueHighOperand?: string | undefined;
    lowValueExceptionAction?: string | undefined;
    highValueExceptionAction?: string | undefined;
    exceptionIsException?: boolean | undefined;
    exceptionHighIsException?: boolean | undefined;
    showHighExceptionFlag?: boolean | undefined;
    showLowExceptionFlag?: boolean | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByDate?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IReqTicklerQuestionCustomModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reqQuestionCovenantId = data["reqQuestionCovenantId"];
            this.reqQuestionDefinitionId = data["reqQuestionDefinitionId"];
            this.ticklerDefinitionID = data["ticklerDefinitionID"];
            this.requirementID = data["requirementID"];
            this.reqQuestionResultCovenantId = data["reqQuestionResultCovenantId"];
            this.questionDefinitionType = data["questionDefinitionType"];
            this.descriptionNotes = data["descriptionNotes"];
            this.questionName = data["questionName"];
            this.questionText = data["questionText"];
            this.dataType = data["dataType"];
            this.actualDate = data["actualDate"];
            this.actualBitValue = data["actualBitValue"];
            this.actualText = data["actualText"];
            this.actualIntValue = data["actualIntValue"];
            this.actualDecimalValue = data["actualDecimalValue"];
            this.expectedValueDate = data["expectedValueDate"];
            this.expectedValueDateOperand = data["expectedValueDateOperand"];
            this.expectedValueHighDate = data["expectedValueHighDate"];
            this.expectedValueHighDateOperand = data["expectedValueHighDateOperand"];
            this.expectedValueBit = data["expectedValueBit"];
            this.expectedValueInt = data["expectedValueInt"];
            this.expectedValueDecimal = data["expectedValueDecimal"];
            this.expectedValueVarchar = data["expectedValueVarchar"];
            this.expectedValueLowOperand = data["expectedValueLowOperand"];
            this.expectedValueHigh = data["expectedValueHigh"];
            this.expectedValueHighOperand = data["expectedValueHighOperand"];
            this.lowValueExceptionAction = data["lowValueExceptionAction"];
            this.highValueExceptionAction = data["highValueExceptionAction"];
            this.exceptionIsException = data["exceptionIsException"];
            this.exceptionHighIsException = data["exceptionHighIsException"];
            this.showHighExceptionFlag = data["showHighExceptionFlag"];
            this.showLowExceptionFlag = data["showLowExceptionFlag"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"];
            this.lastModBy = data["lastModBy"];
            this.lastModByDate = data["lastModByDate"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): ReqTicklerQuestionCustomModel {
        data = typeof data === 'object' ? data : {};
        let result = new ReqTicklerQuestionCustomModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reqQuestionCovenantId"] = this.reqQuestionCovenantId;
        data["reqQuestionDefinitionId"] = this.reqQuestionDefinitionId;
        data["ticklerDefinitionID"] = this.ticklerDefinitionID;
        data["requirementID"] = this.requirementID;
        data["reqQuestionResultCovenantId"] = this.reqQuestionResultCovenantId;
        data["questionDefinitionType"] = this.questionDefinitionType;
        data["descriptionNotes"] = this.descriptionNotes;
        data["questionName"] = this.questionName;
        data["questionText"] = this.questionText;
        data["dataType"] = this.dataType;
        data["actualDate"] = this.actualDate;
        data["actualBitValue"] = this.actualBitValue;
        data["actualText"] = this.actualText;
        data["actualIntValue"] = this.actualIntValue;
        data["actualDecimalValue"] = this.actualDecimalValue;
        data["expectedValueDate"] = this.expectedValueDate;
        data["expectedValueDateOperand"] = this.expectedValueDateOperand;
        data["expectedValueHighDate"] = this.expectedValueHighDate;
        data["expectedValueHighDateOperand"] = this.expectedValueHighDateOperand;
        data["expectedValueBit"] = this.expectedValueBit;
        data["expectedValueInt"] = this.expectedValueInt;
        data["expectedValueDecimal"] = this.expectedValueDecimal;
        data["expectedValueVarchar"] = this.expectedValueVarchar;
        data["expectedValueLowOperand"] = this.expectedValueLowOperand;
        data["expectedValueHigh"] = this.expectedValueHigh;
        data["expectedValueHighOperand"] = this.expectedValueHighOperand;
        data["lowValueExceptionAction"] = this.lowValueExceptionAction;
        data["highValueExceptionAction"] = this.highValueExceptionAction;
        data["exceptionIsException"] = this.exceptionIsException;
        data["exceptionHighIsException"] = this.exceptionHighIsException;
        data["showHighExceptionFlag"] = this.showHighExceptionFlag;
        data["showLowExceptionFlag"] = this.showLowExceptionFlag;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate;
        data["lastModBy"] = this.lastModBy;
        data["lastModByDate"] = this.lastModByDate;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IReqTicklerQuestionCustomModel {
    reqQuestionCovenantId?: number | undefined;
    reqQuestionDefinitionId?: number | undefined;
    ticklerDefinitionID?: number | undefined;
    requirementID?: number | undefined;
    reqQuestionResultCovenantId?: number | undefined;
    questionDefinitionType?: string | undefined;
    descriptionNotes?: string | undefined;
    questionName?: string | undefined;
    questionText?: string | undefined;
    dataType?: string | undefined;
    actualDate?: string | undefined;
    actualBitValue?: boolean | undefined;
    actualText?: string | undefined;
    actualIntValue?: number | undefined;
    actualDecimalValue?: number | undefined;
    expectedValueDate?: string | undefined;
    expectedValueDateOperand?: string | undefined;
    expectedValueHighDate?: string | undefined;
    expectedValueHighDateOperand?: string | undefined;
    expectedValueBit?: boolean | undefined;
    expectedValueInt?: number | undefined;
    expectedValueDecimal?: number | undefined;
    expectedValueVarchar?: string | undefined;
    expectedValueLowOperand?: string | undefined;
    expectedValueHigh?: number | undefined;
    expectedValueHighOperand?: string | undefined;
    lowValueExceptionAction?: string | undefined;
    highValueExceptionAction?: string | undefined;
    exceptionIsException?: boolean | undefined;
    exceptionHighIsException?: boolean | undefined;
    showHighExceptionFlag?: boolean | undefined;
    showLowExceptionFlag?: boolean | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByDate?: string | undefined;
    isActive?: boolean | undefined;
}

export class ReqDefinitionQuestionCustomModel implements IReqDefinitionQuestionCustomModel {
    reqQuestionDefinitionId?: number | undefined;
    reqDefinitionId?: number | undefined;
    reqQuestionResultId?: number | undefined;
    actualDate?: string | undefined;
    actualBitValue?: boolean | undefined;
    actualText?: string | undefined;
    actualIntValue?: number | undefined;
    actualDecimalValue?: number | undefined;
    questionDefinitionType?: string | undefined;
    descriptionNotes?: string | undefined;
    questionName?: string | undefined;
    questionText?: string | undefined;
    dataType?: string | undefined;
    showHighExceptionFlag?: boolean | undefined;
    showLowExceptionFlag?: boolean | undefined;
    expectedValueHigh?: string | undefined;
    expectedValueLow?: string | undefined;
    expectedValueInt?: number | undefined;
    expectedValueBit?: boolean | undefined;
    expectedValueLowOperand?: string | undefined;
    expectedValueHighOperand?: string | undefined;
    expectedValueDecimal?: number | undefined;
    expectedValueVarchar?: string | undefined;
    expectedValueDate?: string | undefined;
    lowValueExceptionAction?: string | undefined;
    highValueExceptionAction?: string | undefined;
    exceptionLowIsException?: boolean | undefined;
    exceptionHighIsException?: boolean | undefined;
    createdBy?: string | undefined;

    constructor(data?: IReqDefinitionQuestionCustomModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reqQuestionDefinitionId = data["reqQuestionDefinitionId"];
            this.reqDefinitionId = data["reqDefinitionId"];
            this.reqQuestionResultId = data["reqQuestionResultId"];
            this.actualDate = data["actualDate"];
            this.actualBitValue = data["actualBitValue"];
            this.actualText = data["actualText"];
            this.actualIntValue = data["actualIntValue"];
            this.actualDecimalValue = data["actualDecimalValue"];
            this.questionDefinitionType = data["questionDefinitionType"];
            this.descriptionNotes = data["descriptionNotes"];
            this.questionName = data["questionName"];
            this.questionText = data["questionText"];
            this.dataType = data["dataType"];
            this.showHighExceptionFlag = data["showHighExceptionFlag"];
            this.showLowExceptionFlag = data["showLowExceptionFlag"];
            this.expectedValueHigh = data["expectedValueHigh"];
            this.expectedValueLow = data["expectedValueLow"];
            this.expectedValueInt = data["expectedValueInt"];
            this.expectedValueBit = data["expectedValueBit"];
            this.expectedValueLowOperand = data["expectedValueLowOperand"];
            this.expectedValueHighOperand = data["expectedValueHighOperand"];
            this.expectedValueDecimal = data["expectedValueDecimal"];
            this.expectedValueVarchar = data["expectedValueVarchar"];
            this.expectedValueDate = data["expectedValueDate"];
            this.lowValueExceptionAction = data["lowValueExceptionAction"];
            this.highValueExceptionAction = data["highValueExceptionAction"];
            this.exceptionLowIsException = data["exceptionLowIsException"];
            this.exceptionHighIsException = data["exceptionHighIsException"];
            this.createdBy = data["createdBy"];
        }
    }

    static fromJS(data: any): ReqDefinitionQuestionCustomModel {
        data = typeof data === 'object' ? data : {};
        let result = new ReqDefinitionQuestionCustomModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reqQuestionDefinitionId"] = this.reqQuestionDefinitionId;
        data["reqDefinitionId"] = this.reqDefinitionId;
        data["reqQuestionResultId"] = this.reqQuestionResultId;
        data["actualDate"] = this.actualDate;
        data["actualBitValue"] = this.actualBitValue;
        data["actualText"] = this.actualText;
        data["actualIntValue"] = this.actualIntValue;
        data["actualDecimalValue"] = this.actualDecimalValue;
        data["questionDefinitionType"] = this.questionDefinitionType;
        data["descriptionNotes"] = this.descriptionNotes;
        data["questionName"] = this.questionName;
        data["questionText"] = this.questionText;
        data["dataType"] = this.dataType;
        data["showHighExceptionFlag"] = this.showHighExceptionFlag;
        data["showLowExceptionFlag"] = this.showLowExceptionFlag;
        data["expectedValueHigh"] = this.expectedValueHigh;
        data["expectedValueLow"] = this.expectedValueLow;
        data["expectedValueInt"] = this.expectedValueInt;
        data["expectedValueBit"] = this.expectedValueBit;
        data["expectedValueLowOperand"] = this.expectedValueLowOperand;
        data["expectedValueHighOperand"] = this.expectedValueHighOperand;
        data["expectedValueDecimal"] = this.expectedValueDecimal;
        data["expectedValueVarchar"] = this.expectedValueVarchar;
        data["expectedValueDate"] = this.expectedValueDate;
        data["lowValueExceptionAction"] = this.lowValueExceptionAction;
        data["highValueExceptionAction"] = this.highValueExceptionAction;
        data["exceptionLowIsException"] = this.exceptionLowIsException;
        data["exceptionHighIsException"] = this.exceptionHighIsException;
        data["createdBy"] = this.createdBy;
        return data; 
    }
}

export interface IReqDefinitionQuestionCustomModel {
    reqQuestionDefinitionId?: number | undefined;
    reqDefinitionId?: number | undefined;
    reqQuestionResultId?: number | undefined;
    actualDate?: string | undefined;
    actualBitValue?: boolean | undefined;
    actualText?: string | undefined;
    actualIntValue?: number | undefined;
    actualDecimalValue?: number | undefined;
    questionDefinitionType?: string | undefined;
    descriptionNotes?: string | undefined;
    questionName?: string | undefined;
    questionText?: string | undefined;
    dataType?: string | undefined;
    showHighExceptionFlag?: boolean | undefined;
    showLowExceptionFlag?: boolean | undefined;
    expectedValueHigh?: string | undefined;
    expectedValueLow?: string | undefined;
    expectedValueInt?: number | undefined;
    expectedValueBit?: boolean | undefined;
    expectedValueLowOperand?: string | undefined;
    expectedValueHighOperand?: string | undefined;
    expectedValueDecimal?: number | undefined;
    expectedValueVarchar?: string | undefined;
    expectedValueDate?: string | undefined;
    lowValueExceptionAction?: string | undefined;
    highValueExceptionAction?: string | undefined;
    exceptionLowIsException?: boolean | undefined;
    exceptionHighIsException?: boolean | undefined;
    createdBy?: string | undefined;
}

export class DocumentRequirementCustomModel implements IDocumentRequirementCustomModel {
    id?: number | undefined;
    documentId?: number | undefined;
    requirementId?: number | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByDate?: string | undefined;
    isPrimary?: boolean | undefined;

    constructor(data?: IDocumentRequirementCustomModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.documentId = data["documentId"];
            this.requirementId = data["requirementId"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"];
            this.lastModBy = data["lastModBy"];
            this.lastModByDate = data["lastModByDate"];
            this.isPrimary = data["isPrimary"];
        }
    }

    static fromJS(data: any): DocumentRequirementCustomModel {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentRequirementCustomModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentId"] = this.documentId;
        data["requirementId"] = this.requirementId;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate;
        data["lastModBy"] = this.lastModBy;
        data["lastModByDate"] = this.lastModByDate;
        data["isPrimary"] = this.isPrimary;
        return data; 
    }
}

export interface IDocumentRequirementCustomModel {
    id?: number | undefined;
    documentId?: number | undefined;
    requirementId?: number | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByDate?: string | undefined;
    isPrimary?: boolean | undefined;
}

export class DownloadedDocumentCustomModel implements IDownloadedDocumentCustomModel {
    userName?: string | undefined;
    filePath?: string | undefined;
    hubConnectionId?: string | undefined;
    documentId?: number | undefined;
    fileData?: string | undefined;
    docName?: string | undefined;
    dealId?: number | undefined;

    constructor(data?: IDownloadedDocumentCustomModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.filePath = data["filePath"];
            this.hubConnectionId = data["hubConnectionId"];
            this.documentId = data["documentId"];
            this.fileData = data["fileData"];
            this.docName = data["docName"];
            this.dealId = data["dealId"];
        }
    }

    static fromJS(data: any): DownloadedDocumentCustomModel {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadedDocumentCustomModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["filePath"] = this.filePath;
        data["hubConnectionId"] = this.hubConnectionId;
        data["documentId"] = this.documentId;
        data["fileData"] = this.fileData;
        data["docName"] = this.docName;
        data["dealId"] = this.dealId;
        return data; 
    }
}

export interface IDownloadedDocumentCustomModel {
    userName?: string | undefined;
    filePath?: string | undefined;
    hubConnectionId?: string | undefined;
    documentId?: number | undefined;
    fileData?: string | undefined;
    docName?: string | undefined;
    dealId?: number | undefined;
}

export class DownloadedDocDetailsCustomModel implements IDownloadedDocDetailsCustomModel {
    userName?: string | undefined;
    filePath?: string | undefined;
    documentId?: string | undefined;
    docName?: string | undefined;

    constructor(data?: IDownloadedDocDetailsCustomModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.filePath = data["filePath"];
            this.documentId = data["documentId"];
            this.docName = data["docName"];
        }
    }

    static fromJS(data: any): DownloadedDocDetailsCustomModel {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadedDocDetailsCustomModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["filePath"] = this.filePath;
        data["documentId"] = this.documentId;
        data["docName"] = this.docName;
        return data; 
    }
}

export interface IDownloadedDocDetailsCustomModel {
    userName?: string | undefined;
    filePath?: string | undefined;
    documentId?: string | undefined;
    docName?: string | undefined;
}

export class LoanDto implements ILoanDto {
    id?: number | undefined;
    productName?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    dealId?: number | undefined;
    amount?: number | undefined;
    requestTypeDescription?: string | undefined;
    primary?: boolean | undefined;
    productId?: number | undefined;
    partyId?: number | undefined;
    departmentId?: number | undefined;
    active?: boolean | undefined;
    loanNumber?: string | undefined;
    requestType?: string | undefined;
    financingCode?: string | undefined;
    financingTypeCode?: string | undefined;
    openRequirements?: number | undefined;
    category?: string | undefined;
    purposePrimary?: string | undefined;
    purposeSecondary?: string | undefined;
    laserprodocdate?: string | undefined;
    applicationDate?: string | undefined;
    applicationCompleteDate?: string | undefined;
    estimatedClosingDate?: string | undefined;
    departmentName?: string | undefined;
    purposePrimaryName?: string | undefined;
    purposeSecondaryName?: string | undefined;
    fee?: number | undefined;
    respa?: string | undefined;
    noteRate?: number | undefined;
    closeAtTitleCo?: boolean | undefined;
    collateralCount?: number | undefined;

    constructor(data?: ILoanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.productName = data["productName"];
            this.name = data["name"];
            this.description = data["description"];
            this.dealId = data["dealId"];
            this.amount = data["amount"];
            this.requestTypeDescription = data["requestTypeDescription"];
            this.primary = data["primary"];
            this.productId = data["productId"];
            this.partyId = data["partyId"];
            this.departmentId = data["departmentId"];
            this.active = data["active"];
            this.loanNumber = data["loanNumber"];
            this.requestType = data["requestType"];
            this.financingCode = data["financingCode"];
            this.financingTypeCode = data["financingTypeCode"];
            this.openRequirements = data["openRequirements"];
            this.category = data["category"];
            this.purposePrimary = data["purposePrimary"];
            this.purposeSecondary = data["purposeSecondary"];
            this.laserprodocdate = data["laserprodocdate"];
            this.applicationDate = data["applicationDate"];
            this.applicationCompleteDate = data["applicationCompleteDate"];
            this.estimatedClosingDate = data["estimatedClosingDate"];
            this.departmentName = data["departmentName"];
            this.purposePrimaryName = data["purposePrimaryName"];
            this.purposeSecondaryName = data["purposeSecondaryName"];
            this.fee = data["fee"];
            this.respa = data["respa"];
            this.noteRate = data["noteRate"];
            this.closeAtTitleCo = data["closeAtTitleCo"];
            this.collateralCount = data["collateralCount"];
        }
    }

    static fromJS(data: any): LoanDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productName"] = this.productName;
        data["name"] = this.name;
        data["description"] = this.description;
        data["dealId"] = this.dealId;
        data["amount"] = this.amount;
        data["requestTypeDescription"] = this.requestTypeDescription;
        data["primary"] = this.primary;
        data["productId"] = this.productId;
        data["partyId"] = this.partyId;
        data["departmentId"] = this.departmentId;
        data["active"] = this.active;
        data["loanNumber"] = this.loanNumber;
        data["requestType"] = this.requestType;
        data["financingCode"] = this.financingCode;
        data["financingTypeCode"] = this.financingTypeCode;
        data["openRequirements"] = this.openRequirements;
        data["category"] = this.category;
        data["purposePrimary"] = this.purposePrimary;
        data["purposeSecondary"] = this.purposeSecondary;
        data["laserprodocdate"] = this.laserprodocdate;
        data["applicationDate"] = this.applicationDate;
        data["applicationCompleteDate"] = this.applicationCompleteDate;
        data["estimatedClosingDate"] = this.estimatedClosingDate;
        data["departmentName"] = this.departmentName;
        data["purposePrimaryName"] = this.purposePrimaryName;
        data["purposeSecondaryName"] = this.purposeSecondaryName;
        data["fee"] = this.fee;
        data["respa"] = this.respa;
        data["noteRate"] = this.noteRate;
        data["closeAtTitleCo"] = this.closeAtTitleCo;
        data["collateralCount"] = this.collateralCount;
        return data; 
    }
}

export interface ILoanDto {
    id?: number | undefined;
    productName?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    dealId?: number | undefined;
    amount?: number | undefined;
    requestTypeDescription?: string | undefined;
    primary?: boolean | undefined;
    productId?: number | undefined;
    partyId?: number | undefined;
    departmentId?: number | undefined;
    active?: boolean | undefined;
    loanNumber?: string | undefined;
    requestType?: string | undefined;
    financingCode?: string | undefined;
    financingTypeCode?: string | undefined;
    openRequirements?: number | undefined;
    category?: string | undefined;
    purposePrimary?: string | undefined;
    purposeSecondary?: string | undefined;
    laserprodocdate?: string | undefined;
    applicationDate?: string | undefined;
    applicationCompleteDate?: string | undefined;
    estimatedClosingDate?: string | undefined;
    departmentName?: string | undefined;
    purposePrimaryName?: string | undefined;
    purposeSecondaryName?: string | undefined;
    fee?: number | undefined;
    respa?: string | undefined;
    noteRate?: number | undefined;
    closeAtTitleCo?: boolean | undefined;
    collateralCount?: number | undefined;
}

export class LoanDetailsDto implements ILoanDetailsDto {
    id?: number | undefined;
    productName?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    points?: string | undefined;
    spreadRate?: number | undefined;
    depositExpected?: number | undefined;
    noteRate?: number | undefined;
    floorRate?: number | undefined;
    dealId?: number | undefined;
    estimatedClosingDate?: string | undefined;
    estimatedApprovalDate?: string | undefined;
    amount?: number | undefined;
    useOfProceeds?: string | undefined;
    term?: string | undefined;
    fee?: number | undefined;
    roe?: number | undefined;
    comment?: string | undefined;
    pricingIndex?: string | undefined;
    productId?: number | undefined;
    partyId?: number | undefined;
    departmentId?: number | undefined;
    pipelineStatus?: string | undefined;
    pipelineReason?: string | undefined;
    active?: boolean | undefined;
    structure?: string | undefined;
    anticipatedLTV?: string | undefined;
    anticipatedCommittee?: string | undefined;
    docsNeededAtHand?: string | undefined;
    closeAtTitleCo?: boolean | undefined;
    feeRange?: string | undefined;
    paymentMethod?: string | undefined;
    roeRange?: string | undefined;
    escrowTaxInsurance?: string | undefined;
    aftProtAcct?: string | undefined;
    fileProjections?: string | undefined;
    amortTerm?: string | undefined;
    expectedLife?: string | undefined;
    initialFixedPeriod?: string | undefined;
    riskRating?: string | undefined;
    loanNumber?: string | undefined;
    requestType?: string | undefined;
    financingCode?: string | undefined;
    financingTypeCode?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    requestTypeDescription?: string | undefined;
    lpTransNo?: string | undefined;
    primary?: boolean | undefined;
    openRequirements?: number | undefined;
    pricingComment?: string | undefined;
    closingComments?: string | undefined;
    category?: string | undefined;
    decisionpronumber?: number | undefined;
    laserprodocdate?: string | undefined;
    rush?: boolean | undefined;
    owneroccupiedflag?: boolean | undefined;
    interestOnly?: boolean | undefined;
    loanEstimate?: boolean | undefined;
    employeeLoan?: boolean | undefined;
    applicationDate?: string | undefined;
    applicationCompleteDate?: string | undefined;
    prequal?: string | undefined;
    respa?: string | undefined;
    hmda?: string | undefined;
    cic?: string | undefined;
    actionTakenDate?: string | undefined;
    probabilityCode?: string | undefined;
    probabilityText?: string | undefined;
    lastModBy?: string | undefined;
    lastModByDate?: string | undefined;
    purposePrimary?: string | undefined;
    purposeSecondary?: string | undefined;
    collateralCount?: number | undefined;
    actualClosingDate?: string | undefined;
    intendedUseOfFunds?: string | undefined;
    departmentName?: string | undefined;
    categoryName?: string | undefined;
    purposePrimaryName?: string | undefined;
    purposeSecondaryName?: string | undefined;
    contractApprovalDeadline?: string | undefined;
    probabilityName?: string | undefined;
    escrowtext?: string | undefined;
    pricingIndextext?: string | undefined;
    initialfixedtext?: string | undefined;
    loantovaluetext?: string | undefined;
    paymentTypetext?: string | undefined;
    feestext?: string | undefined;
    address1?: string | undefined;
    address2?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zip?: string | undefined;

    constructor(data?: ILoanDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.productName = data["productName"];
            this.name = data["name"];
            this.description = data["description"];
            this.points = data["points"];
            this.spreadRate = data["spreadRate"];
            this.depositExpected = data["depositExpected"];
            this.noteRate = data["noteRate"];
            this.floorRate = data["floorRate"];
            this.dealId = data["dealId"];
            this.estimatedClosingDate = data["estimatedClosingDate"];
            this.estimatedApprovalDate = data["estimatedApprovalDate"];
            this.amount = data["amount"];
            this.useOfProceeds = data["useOfProceeds"];
            this.term = data["term"];
            this.fee = data["fee"];
            this.roe = data["roe"];
            this.comment = data["comment"];
            this.pricingIndex = data["pricingIndex"];
            this.productId = data["productId"];
            this.partyId = data["partyId"];
            this.departmentId = data["departmentId"];
            this.pipelineStatus = data["pipelineStatus"];
            this.pipelineReason = data["pipelineReason"];
            this.active = data["active"];
            this.structure = data["structure"];
            this.anticipatedLTV = data["anticipatedLTV"];
            this.anticipatedCommittee = data["anticipatedCommittee"];
            this.docsNeededAtHand = data["docsNeededAtHand"];
            this.closeAtTitleCo = data["closeAtTitleCo"];
            this.feeRange = data["feeRange"];
            this.paymentMethod = data["paymentMethod"];
            this.roeRange = data["roeRange"];
            this.escrowTaxInsurance = data["escrowTaxInsurance"];
            this.aftProtAcct = data["aftProtAcct"];
            this.fileProjections = data["fileProjections"];
            this.amortTerm = data["amortTerm"];
            this.expectedLife = data["expectedLife"];
            this.initialFixedPeriod = data["initialFixedPeriod"];
            this.riskRating = data["riskRating"];
            this.loanNumber = data["loanNumber"];
            this.requestType = data["requestType"];
            this.financingCode = data["financingCode"];
            this.financingTypeCode = data["financingTypeCode"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"];
            this.requestTypeDescription = data["requestTypeDescription"];
            this.lpTransNo = data["lpTransNo"];
            this.primary = data["primary"];
            this.openRequirements = data["openRequirements"];
            this.pricingComment = data["pricingComment"];
            this.closingComments = data["closingComments"];
            this.category = data["category"];
            this.decisionpronumber = data["decisionpronumber"];
            this.laserprodocdate = data["laserprodocdate"];
            this.rush = data["rush"];
            this.owneroccupiedflag = data["owneroccupiedflag"];
            this.interestOnly = data["interestOnly"];
            this.loanEstimate = data["loanEstimate"];
            this.employeeLoan = data["employeeLoan"];
            this.applicationDate = data["applicationDate"];
            this.applicationCompleteDate = data["applicationCompleteDate"];
            this.prequal = data["prequal"];
            this.respa = data["respa"];
            this.hmda = data["hmda"];
            this.cic = data["cic"];
            this.actionTakenDate = data["actionTakenDate"];
            this.probabilityCode = data["probabilityCode"];
            this.probabilityText = data["probabilityText"];
            this.lastModBy = data["lastModBy"];
            this.lastModByDate = data["lastModByDate"];
            this.purposePrimary = data["purposePrimary"];
            this.purposeSecondary = data["purposeSecondary"];
            this.collateralCount = data["collateralCount"];
            this.actualClosingDate = data["actualClosingDate"];
            this.intendedUseOfFunds = data["intendedUseOfFunds"];
            this.departmentName = data["departmentName"];
            this.categoryName = data["categoryName"];
            this.purposePrimaryName = data["purposePrimaryName"];
            this.purposeSecondaryName = data["purposeSecondaryName"];
            this.contractApprovalDeadline = data["contractApprovalDeadline"];
            this.probabilityName = data["probabilityName"];
            this.escrowtext = data["escrowtext"];
            this.pricingIndextext = data["pricingIndextext"];
            this.initialfixedtext = data["initialfixedtext"];
            this.loantovaluetext = data["loantovaluetext"];
            this.paymentTypetext = data["paymentTypetext"];
            this.feestext = data["feestext"];
            this.address1 = data["address1"];
            this.address2 = data["address2"];
            this.city = data["city"];
            this.state = data["state"];
            this.zip = data["zip"];
        }
    }

    static fromJS(data: any): LoanDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoanDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productName"] = this.productName;
        data["name"] = this.name;
        data["description"] = this.description;
        data["points"] = this.points;
        data["spreadRate"] = this.spreadRate;
        data["depositExpected"] = this.depositExpected;
        data["noteRate"] = this.noteRate;
        data["floorRate"] = this.floorRate;
        data["dealId"] = this.dealId;
        data["estimatedClosingDate"] = this.estimatedClosingDate;
        data["estimatedApprovalDate"] = this.estimatedApprovalDate;
        data["amount"] = this.amount;
        data["useOfProceeds"] = this.useOfProceeds;
        data["term"] = this.term;
        data["fee"] = this.fee;
        data["roe"] = this.roe;
        data["comment"] = this.comment;
        data["pricingIndex"] = this.pricingIndex;
        data["productId"] = this.productId;
        data["partyId"] = this.partyId;
        data["departmentId"] = this.departmentId;
        data["pipelineStatus"] = this.pipelineStatus;
        data["pipelineReason"] = this.pipelineReason;
        data["active"] = this.active;
        data["structure"] = this.structure;
        data["anticipatedLTV"] = this.anticipatedLTV;
        data["anticipatedCommittee"] = this.anticipatedCommittee;
        data["docsNeededAtHand"] = this.docsNeededAtHand;
        data["closeAtTitleCo"] = this.closeAtTitleCo;
        data["feeRange"] = this.feeRange;
        data["paymentMethod"] = this.paymentMethod;
        data["roeRange"] = this.roeRange;
        data["escrowTaxInsurance"] = this.escrowTaxInsurance;
        data["aftProtAcct"] = this.aftProtAcct;
        data["fileProjections"] = this.fileProjections;
        data["amortTerm"] = this.amortTerm;
        data["expectedLife"] = this.expectedLife;
        data["initialFixedPeriod"] = this.initialFixedPeriod;
        data["riskRating"] = this.riskRating;
        data["loanNumber"] = this.loanNumber;
        data["requestType"] = this.requestType;
        data["financingCode"] = this.financingCode;
        data["financingTypeCode"] = this.financingTypeCode;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate;
        data["requestTypeDescription"] = this.requestTypeDescription;
        data["lpTransNo"] = this.lpTransNo;
        data["primary"] = this.primary;
        data["openRequirements"] = this.openRequirements;
        data["pricingComment"] = this.pricingComment;
        data["closingComments"] = this.closingComments;
        data["category"] = this.category;
        data["decisionpronumber"] = this.decisionpronumber;
        data["laserprodocdate"] = this.laserprodocdate;
        data["rush"] = this.rush;
        data["owneroccupiedflag"] = this.owneroccupiedflag;
        data["interestOnly"] = this.interestOnly;
        data["loanEstimate"] = this.loanEstimate;
        data["employeeLoan"] = this.employeeLoan;
        data["applicationDate"] = this.applicationDate;
        data["applicationCompleteDate"] = this.applicationCompleteDate;
        data["prequal"] = this.prequal;
        data["respa"] = this.respa;
        data["hmda"] = this.hmda;
        data["cic"] = this.cic;
        data["actionTakenDate"] = this.actionTakenDate;
        data["probabilityCode"] = this.probabilityCode;
        data["probabilityText"] = this.probabilityText;
        data["lastModBy"] = this.lastModBy;
        data["lastModByDate"] = this.lastModByDate;
        data["purposePrimary"] = this.purposePrimary;
        data["purposeSecondary"] = this.purposeSecondary;
        data["collateralCount"] = this.collateralCount;
        data["actualClosingDate"] = this.actualClosingDate;
        data["intendedUseOfFunds"] = this.intendedUseOfFunds;
        data["departmentName"] = this.departmentName;
        data["categoryName"] = this.categoryName;
        data["purposePrimaryName"] = this.purposePrimaryName;
        data["purposeSecondaryName"] = this.purposeSecondaryName;
        data["contractApprovalDeadline"] = this.contractApprovalDeadline;
        data["probabilityName"] = this.probabilityName;
        data["escrowtext"] = this.escrowtext;
        data["pricingIndextext"] = this.pricingIndextext;
        data["initialfixedtext"] = this.initialfixedtext;
        data["loantovaluetext"] = this.loantovaluetext;
        data["paymentTypetext"] = this.paymentTypetext;
        data["feestext"] = this.feestext;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zip"] = this.zip;
        return data; 
    }
}

export interface ILoanDetailsDto {
    id?: number | undefined;
    productName?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    points?: string | undefined;
    spreadRate?: number | undefined;
    depositExpected?: number | undefined;
    noteRate?: number | undefined;
    floorRate?: number | undefined;
    dealId?: number | undefined;
    estimatedClosingDate?: string | undefined;
    estimatedApprovalDate?: string | undefined;
    amount?: number | undefined;
    useOfProceeds?: string | undefined;
    term?: string | undefined;
    fee?: number | undefined;
    roe?: number | undefined;
    comment?: string | undefined;
    pricingIndex?: string | undefined;
    productId?: number | undefined;
    partyId?: number | undefined;
    departmentId?: number | undefined;
    pipelineStatus?: string | undefined;
    pipelineReason?: string | undefined;
    active?: boolean | undefined;
    structure?: string | undefined;
    anticipatedLTV?: string | undefined;
    anticipatedCommittee?: string | undefined;
    docsNeededAtHand?: string | undefined;
    closeAtTitleCo?: boolean | undefined;
    feeRange?: string | undefined;
    paymentMethod?: string | undefined;
    roeRange?: string | undefined;
    escrowTaxInsurance?: string | undefined;
    aftProtAcct?: string | undefined;
    fileProjections?: string | undefined;
    amortTerm?: string | undefined;
    expectedLife?: string | undefined;
    initialFixedPeriod?: string | undefined;
    riskRating?: string | undefined;
    loanNumber?: string | undefined;
    requestType?: string | undefined;
    financingCode?: string | undefined;
    financingTypeCode?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    requestTypeDescription?: string | undefined;
    lpTransNo?: string | undefined;
    primary?: boolean | undefined;
    openRequirements?: number | undefined;
    pricingComment?: string | undefined;
    closingComments?: string | undefined;
    category?: string | undefined;
    decisionpronumber?: number | undefined;
    laserprodocdate?: string | undefined;
    rush?: boolean | undefined;
    owneroccupiedflag?: boolean | undefined;
    interestOnly?: boolean | undefined;
    loanEstimate?: boolean | undefined;
    employeeLoan?: boolean | undefined;
    applicationDate?: string | undefined;
    applicationCompleteDate?: string | undefined;
    prequal?: string | undefined;
    respa?: string | undefined;
    hmda?: string | undefined;
    cic?: string | undefined;
    actionTakenDate?: string | undefined;
    probabilityCode?: string | undefined;
    probabilityText?: string | undefined;
    lastModBy?: string | undefined;
    lastModByDate?: string | undefined;
    purposePrimary?: string | undefined;
    purposeSecondary?: string | undefined;
    collateralCount?: number | undefined;
    actualClosingDate?: string | undefined;
    intendedUseOfFunds?: string | undefined;
    departmentName?: string | undefined;
    categoryName?: string | undefined;
    purposePrimaryName?: string | undefined;
    purposeSecondaryName?: string | undefined;
    contractApprovalDeadline?: string | undefined;
    probabilityName?: string | undefined;
    escrowtext?: string | undefined;
    pricingIndextext?: string | undefined;
    initialfixedtext?: string | undefined;
    loantovaluetext?: string | undefined;
    paymentTypetext?: string | undefined;
    feestext?: string | undefined;
    address1?: string | undefined;
    address2?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zip?: string | undefined;
}

export class MessageDto implements IMessageDto {
    messageUsers?: UserDropdownDto[] | undefined;
    id?: number | undefined;
    author?: string | undefined;
    authorId?: string | undefined;
    recipient?: string | undefined;
    plainContent?: string | undefined;
    htmlContent?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    threadId?: number | undefined;
    subject?: string | undefined;
    hasBeenRead?: boolean | undefined;
    dealId?: number | undefined;
    dealPrimaryPartyName?: string | undefined;
    lastModDate?: string | undefined;
    lastModBy?: string | undefined;
    archive?: boolean | undefined;
    memoToFile?: boolean | undefined;
    sendToOfficer?: boolean | undefined;
    userProfileURL?: string | undefined;
    requirementId?: number | undefined;
    threadName?: string | undefined;

    constructor(data?: IMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["messageUsers"] && data["messageUsers"].constructor === Array) {
                this.messageUsers = [];
                for (let item of data["messageUsers"])
                    this.messageUsers.push(UserDropdownDto.fromJS(item));
            }
            this.id = data["id"];
            this.author = data["author"];
            this.authorId = data["authorId"];
            this.recipient = data["recipient"];
            this.plainContent = data["plainContent"];
            this.htmlContent = data["htmlContent"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"];
            this.threadId = data["threadId"];
            this.subject = data["subject"];
            this.hasBeenRead = data["hasBeenRead"];
            this.dealId = data["dealId"];
            this.dealPrimaryPartyName = data["dealPrimaryPartyName"];
            this.lastModDate = data["lastModDate"];
            this.lastModBy = data["lastModBy"];
            this.archive = data["archive"];
            this.memoToFile = data["memoToFile"];
            this.sendToOfficer = data["sendToOfficer"];
            this.userProfileURL = data["userProfileURL"];
            this.requirementId = data["requirementId"];
            this.threadName = data["threadName"];
        }
    }

    static fromJS(data: any): MessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.messageUsers && this.messageUsers.constructor === Array) {
            data["messageUsers"] = [];
            for (let item of this.messageUsers)
                data["messageUsers"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["author"] = this.author;
        data["authorId"] = this.authorId;
        data["recipient"] = this.recipient;
        data["plainContent"] = this.plainContent;
        data["htmlContent"] = this.htmlContent;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate;
        data["threadId"] = this.threadId;
        data["subject"] = this.subject;
        data["hasBeenRead"] = this.hasBeenRead;
        data["dealId"] = this.dealId;
        data["dealPrimaryPartyName"] = this.dealPrimaryPartyName;
        data["lastModDate"] = this.lastModDate;
        data["lastModBy"] = this.lastModBy;
        data["archive"] = this.archive;
        data["memoToFile"] = this.memoToFile;
        data["sendToOfficer"] = this.sendToOfficer;
        data["userProfileURL"] = this.userProfileURL;
        data["requirementId"] = this.requirementId;
        data["threadName"] = this.threadName;
        return data; 
    }
}

export interface IMessageDto {
    messageUsers?: UserDropdownDto[] | undefined;
    id?: number | undefined;
    author?: string | undefined;
    authorId?: string | undefined;
    recipient?: string | undefined;
    plainContent?: string | undefined;
    htmlContent?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    threadId?: number | undefined;
    subject?: string | undefined;
    hasBeenRead?: boolean | undefined;
    dealId?: number | undefined;
    dealPrimaryPartyName?: string | undefined;
    lastModDate?: string | undefined;
    lastModBy?: string | undefined;
    archive?: boolean | undefined;
    memoToFile?: boolean | undefined;
    sendToOfficer?: boolean | undefined;
    userProfileURL?: string | undefined;
    requirementId?: number | undefined;
    threadName?: string | undefined;
}

export class UserDropdownDto implements IUserDropdownDto {
    id?: string | undefined;
    text?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUserDropdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.text = data["text"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): UserDropdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDropdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUserDropdownDto {
    id?: string | undefined;
    text?: string | undefined;
    description?: string | undefined;
}

export class MessageThreadDto implements IMessageThreadDto {
    id?: number | undefined;
    dealId?: number | undefined;
    requirementId?: number | undefined;
    threadUsers?: MessageThreadUserDto[] | undefined;
    title?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModDate?: string | undefined;

    constructor(data?: IMessageThreadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.dealId = data["dealId"];
            this.requirementId = data["requirementId"];
            if (data["threadUsers"] && data["threadUsers"].constructor === Array) {
                this.threadUsers = [];
                for (let item of data["threadUsers"])
                    this.threadUsers.push(MessageThreadUserDto.fromJS(item));
            }
            this.title = data["title"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"];
            this.lastModBy = data["lastModBy"];
            this.lastModDate = data["lastModDate"];
        }
    }

    static fromJS(data: any): MessageThreadDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageThreadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dealId"] = this.dealId;
        data["requirementId"] = this.requirementId;
        if (this.threadUsers && this.threadUsers.constructor === Array) {
            data["threadUsers"] = [];
            for (let item of this.threadUsers)
                data["threadUsers"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate;
        data["lastModBy"] = this.lastModBy;
        data["lastModDate"] = this.lastModDate;
        return data; 
    }
}

export interface IMessageThreadDto {
    id?: number | undefined;
    dealId?: number | undefined;
    requirementId?: number | undefined;
    threadUsers?: MessageThreadUserDto[] | undefined;
    title?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModDate?: string | undefined;
}

export class MessageThreadUserDto implements IMessageThreadUserDto {
    threadUserId?: number | undefined;
    threadId?: number | undefined;
    userId?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModDate?: string | undefined;

    constructor(data?: IMessageThreadUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadUserId = data["threadUserId"];
            this.threadId = data["threadId"];
            this.userId = data["userId"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"];
            this.lastModBy = data["lastModBy"];
            this.lastModDate = data["lastModDate"];
        }
    }

    static fromJS(data: any): MessageThreadUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageThreadUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadUserId"] = this.threadUserId;
        data["threadId"] = this.threadId;
        data["userId"] = this.userId;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate;
        data["lastModBy"] = this.lastModBy;
        data["lastModDate"] = this.lastModDate;
        return data; 
    }
}

export interface IMessageThreadUserDto {
    threadUserId?: number | undefined;
    threadId?: number | undefined;
    userId?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModDate?: string | undefined;
}

export class UserDropdownCustomModel implements IUserDropdownCustomModel {
    id?: string | undefined;
    text?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUserDropdownCustomModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.text = data["text"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): UserDropdownCustomModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserDropdownCustomModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUserDropdownCustomModel {
    id?: string | undefined;
    text?: string | undefined;
    description?: string | undefined;
}

export class NotificationRequestDto implements INotificationRequestDto {
    notifyRequestId?: number | undefined;
    processStageFunctionId?: number | undefined;
    notifyDefinitionId?: string | undefined;
    requestUserId?: string | undefined;
    processStageFunctionType?: string | undefined;
    processId?: string | undefined;
    stageId?: string | undefined;
    functionId?: string | undefined;
    processStageFunctionDetail?: string | undefined;
    processStageFunctionStageId?: number | undefined;
    assignedUserId?: string | undefined;
    notifyParameters?: string | undefined;
    dealId?: number | undefined;
    requirementId?: number | undefined;
    partyId?: number | undefined;

    constructor(data?: INotificationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.notifyRequestId = data["notifyRequestId"];
            this.processStageFunctionId = data["processStageFunctionId"];
            this.notifyDefinitionId = data["notifyDefinitionId"];
            this.requestUserId = data["requestUserId"];
            this.processStageFunctionType = data["processStageFunctionType"];
            this.processId = data["processId"];
            this.stageId = data["stageId"];
            this.functionId = data["functionId"];
            this.processStageFunctionDetail = data["processStageFunctionDetail"];
            this.processStageFunctionStageId = data["processStageFunctionStageId"];
            this.assignedUserId = data["assignedUserId"];
            this.notifyParameters = data["notifyParameters"];
            this.dealId = data["dealId"];
            this.requirementId = data["requirementId"];
            this.partyId = data["partyId"];
        }
    }

    static fromJS(data: any): NotificationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notifyRequestId"] = this.notifyRequestId;
        data["processStageFunctionId"] = this.processStageFunctionId;
        data["notifyDefinitionId"] = this.notifyDefinitionId;
        data["requestUserId"] = this.requestUserId;
        data["processStageFunctionType"] = this.processStageFunctionType;
        data["processId"] = this.processId;
        data["stageId"] = this.stageId;
        data["functionId"] = this.functionId;
        data["processStageFunctionDetail"] = this.processStageFunctionDetail;
        data["processStageFunctionStageId"] = this.processStageFunctionStageId;
        data["assignedUserId"] = this.assignedUserId;
        data["notifyParameters"] = this.notifyParameters;
        data["dealId"] = this.dealId;
        data["requirementId"] = this.requirementId;
        data["partyId"] = this.partyId;
        return data; 
    }
}

export interface INotificationRequestDto {
    notifyRequestId?: number | undefined;
    processStageFunctionId?: number | undefined;
    notifyDefinitionId?: string | undefined;
    requestUserId?: string | undefined;
    processStageFunctionType?: string | undefined;
    processId?: string | undefined;
    stageId?: string | undefined;
    functionId?: string | undefined;
    processStageFunctionDetail?: string | undefined;
    processStageFunctionStageId?: number | undefined;
    assignedUserId?: string | undefined;
    notifyParameters?: string | undefined;
    dealId?: number | undefined;
    requirementId?: number | undefined;
    partyId?: number | undefined;
}

export class DealParticipantDto implements IDealParticipantDto {
    dealUserId?: number | undefined;
    dealId?: number | undefined;
    createUserId?: string | undefined;
    personId?: string | undefined;
    personName?: string | undefined;
    participationId?: string | undefined;
    participation?: string | undefined;
    personPhone?: string | undefined;
    hostId?: string | undefined;
    branchId?: number | undefined;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    nmls?: string | undefined;
    doNotShowDealUser?: boolean | undefined;
    primary?: boolean | undefined;
    outOfOffice?: boolean | undefined;
    interimUser?: boolean | undefined;
    userProfileURL?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IDealParticipantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dealUserId = data["dealUserId"];
            this.dealId = data["dealId"];
            this.createUserId = data["createUserId"];
            this.personId = data["personId"];
            this.personName = data["personName"];
            this.participationId = data["participationId"];
            this.participation = data["participation"];
            this.personPhone = data["personPhone"];
            this.hostId = data["hostId"];
            this.branchId = data["branchId"];
            this.branchCode = data["branchCode"];
            this.branchName = data["branchName"];
            this.nmls = data["nmls"];
            this.doNotShowDealUser = data["doNotShowDealUser"];
            this.primary = data["primary"];
            this.outOfOffice = data["outOfOffice"];
            this.interimUser = data["interimUser"];
            this.userProfileURL = data["userProfileURL"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
        }
    }

    static fromJS(data: any): DealParticipantDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealParticipantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dealUserId"] = this.dealUserId;
        data["dealId"] = this.dealId;
        data["createUserId"] = this.createUserId;
        data["personId"] = this.personId;
        data["personName"] = this.personName;
        data["participationId"] = this.participationId;
        data["participation"] = this.participation;
        data["personPhone"] = this.personPhone;
        data["hostId"] = this.hostId;
        data["branchId"] = this.branchId;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["nmls"] = this.nmls;
        data["doNotShowDealUser"] = this.doNotShowDealUser;
        data["primary"] = this.primary;
        data["outOfOffice"] = this.outOfOffice;
        data["interimUser"] = this.interimUser;
        data["userProfileURL"] = this.userProfileURL;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data; 
    }
}

export interface IDealParticipantDto {
    dealUserId?: number | undefined;
    dealId?: number | undefined;
    createUserId?: string | undefined;
    personId?: string | undefined;
    personName?: string | undefined;
    participationId?: string | undefined;
    participation?: string | undefined;
    personPhone?: string | undefined;
    hostId?: string | undefined;
    branchId?: number | undefined;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    nmls?: string | undefined;
    doNotShowDealUser?: boolean | undefined;
    primary?: boolean | undefined;
    outOfOffice?: boolean | undefined;
    interimUser?: boolean | undefined;
    userProfileURL?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
}

export class PartyUserSearchFilterCustomModel implements IPartyUserSearchFilterCustomModel {
    partyType?: string | undefined;
    companyName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    officer?: string | undefined;
    tin?: string | undefined;
    hostId?: string | undefined;
    totalRecords?: number | undefined;

    constructor(data?: IPartyUserSearchFilterCustomModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.partyType = data["partyType"];
            this.companyName = data["companyName"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.officer = data["officer"];
            this.tin = data["tin"];
            this.hostId = data["hostId"];
            this.totalRecords = data["totalRecords"];
        }
    }

    static fromJS(data: any): PartyUserSearchFilterCustomModel {
        data = typeof data === 'object' ? data : {};
        let result = new PartyUserSearchFilterCustomModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["partyType"] = this.partyType;
        data["companyName"] = this.companyName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["officer"] = this.officer;
        data["tin"] = this.tin;
        data["hostId"] = this.hostId;
        data["totalRecords"] = this.totalRecords;
        return data; 
    }
}

export interface IPartyUserSearchFilterCustomModel {
    partyType?: string | undefined;
    companyName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    officer?: string | undefined;
    tin?: string | undefined;
    hostId?: string | undefined;
    totalRecords?: number | undefined;
}

export class PartyDto implements IPartyDto {
    partyId?: number | undefined;
    dealPartyId?: number | undefined;
    name?: string | undefined;
    company?: string | undefined;
    companyId?: number | undefined;
    role?: string | undefined;
    phone?: string | undefined;
    mobilePhone?: string | undefined;
    email?: string | undefined;
    type?: string | undefined;
    entityTypeCode?: string | undefined;
    primary?: boolean | undefined;
    participation?: string | undefined;
    tin?: string | undefined;
    dealId?: number | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zip?: string | undefined;
    street1?: string | undefined;
    street2?: string | undefined;
    hostId?: string | undefined;
    title?: string | undefined;
    openRequirements?: number | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByDate?: string | undefined;
    birthdate?: string | undefined;
    entityTypeName?: string | undefined;

    constructor(data?: IPartyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.partyId = data["partyId"];
            this.dealPartyId = data["dealPartyId"];
            this.name = data["name"];
            this.company = data["company"];
            this.companyId = data["companyId"];
            this.role = data["role"];
            this.phone = data["phone"];
            this.mobilePhone = data["mobilePhone"];
            this.email = data["email"];
            this.type = data["type"];
            this.entityTypeCode = data["entityTypeCode"];
            this.primary = data["primary"];
            this.participation = data["participation"];
            this.tin = data["tin"];
            this.dealId = data["dealId"];
            this.city = data["city"];
            this.state = data["state"];
            this.zip = data["zip"];
            this.street1 = data["street1"];
            this.street2 = data["street2"];
            this.hostId = data["hostId"];
            this.title = data["title"];
            this.openRequirements = data["openRequirements"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"];
            this.lastModBy = data["lastModBy"];
            this.lastModByDate = data["lastModByDate"];
            this.birthdate = data["birthdate"];
            this.entityTypeName = data["entityTypeName"];
        }
    }

    static fromJS(data: any): PartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["partyId"] = this.partyId;
        data["dealPartyId"] = this.dealPartyId;
        data["name"] = this.name;
        data["company"] = this.company;
        data["companyId"] = this.companyId;
        data["role"] = this.role;
        data["phone"] = this.phone;
        data["mobilePhone"] = this.mobilePhone;
        data["email"] = this.email;
        data["type"] = this.type;
        data["entityTypeCode"] = this.entityTypeCode;
        data["primary"] = this.primary;
        data["participation"] = this.participation;
        data["tin"] = this.tin;
        data["dealId"] = this.dealId;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zip"] = this.zip;
        data["street1"] = this.street1;
        data["street2"] = this.street2;
        data["hostId"] = this.hostId;
        data["title"] = this.title;
        data["openRequirements"] = this.openRequirements;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate;
        data["lastModBy"] = this.lastModBy;
        data["lastModByDate"] = this.lastModByDate;
        data["birthdate"] = this.birthdate;
        data["entityTypeName"] = this.entityTypeName;
        return data; 
    }
}

export interface IPartyDto {
    partyId?: number | undefined;
    dealPartyId?: number | undefined;
    name?: string | undefined;
    company?: string | undefined;
    companyId?: number | undefined;
    role?: string | undefined;
    phone?: string | undefined;
    mobilePhone?: string | undefined;
    email?: string | undefined;
    type?: string | undefined;
    entityTypeCode?: string | undefined;
    primary?: boolean | undefined;
    participation?: string | undefined;
    tin?: string | undefined;
    dealId?: number | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zip?: string | undefined;
    street1?: string | undefined;
    street2?: string | undefined;
    hostId?: string | undefined;
    title?: string | undefined;
    openRequirements?: number | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByDate?: string | undefined;
    birthdate?: string | undefined;
    entityTypeName?: string | undefined;
}

export class DocumentDto implements IDocumentDto {
    id?: number | undefined;
    documentDefinitionId?: number | undefined;
    documentDefinitionName?: string | undefined;
    file?: string | undefined;
    name?: string | undefined;
    alternateName?: string | undefined;
    description?: string | undefined;
    recievedDate?: string | undefined;
    asOfDate?: string | undefined;
    expirationDate?: string | undefined;
    uploadDate?: string | undefined;
    primary?: boolean | undefined;
    notes?: string | undefined;
    isIIS?: boolean | undefined;
    dealId?: number | undefined;
    requirementId?: number | undefined;
    mimeType?: string | undefined;
    fileGuid?: string | undefined;
    requirementAttachmentCount?: number | undefined;
    attachedRequirements?: RequirementDto[] | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByFirstname?: string | undefined;
    lastModByLastname?: string | undefined;
    lastModByDate?: string | undefined;
    ecmExportReady?: boolean | undefined;
    ecmExported?: boolean | undefined;
    ecmCabinetCode?: string | undefined;
    ecmFileName?: string | undefined;
    ecmExportedBy?: string | undefined;
    ecmExportedDate?: string | undefined;
    ecmUploadEnabled?: boolean | undefined;
    active?: boolean | undefined;
    setAsOfDate?: boolean | undefined;
    entityIds?: number[] | undefined;
    entityType?: string | undefined;
    requirementAttachDate?: string | undefined;
    docDefinitionCode?: string | undefined;
    createdByFirstname?: string | undefined;
    createdByLastname?: string | undefined;

    constructor(data?: IDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.documentDefinitionId = data["documentDefinitionId"];
            this.documentDefinitionName = data["documentDefinitionName"];
            this.file = data["file"];
            this.name = data["name"];
            this.alternateName = data["alternateName"];
            this.description = data["description"];
            this.recievedDate = data["recievedDate"];
            this.asOfDate = data["asOfDate"];
            this.expirationDate = data["expirationDate"];
            this.uploadDate = data["uploadDate"];
            this.primary = data["primary"];
            this.notes = data["notes"];
            this.isIIS = data["isIIS"];
            this.dealId = data["dealId"];
            this.requirementId = data["requirementId"];
            this.mimeType = data["mimeType"];
            this.fileGuid = data["fileGuid"];
            this.requirementAttachmentCount = data["requirementAttachmentCount"];
            if (data["attachedRequirements"] && data["attachedRequirements"].constructor === Array) {
                this.attachedRequirements = [];
                for (let item of data["attachedRequirements"])
                    this.attachedRequirements.push(RequirementDto.fromJS(item));
            }
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"];
            this.lastModBy = data["lastModBy"];
            this.lastModByFirstname = data["lastModByFirstname"];
            this.lastModByLastname = data["lastModByLastname"];
            this.lastModByDate = data["lastModByDate"];
            this.ecmExportReady = data["ecmExportReady"];
            this.ecmExported = data["ecmExported"];
            this.ecmCabinetCode = data["ecmCabinetCode"];
            this.ecmFileName = data["ecmFileName"];
            this.ecmExportedBy = data["ecmExportedBy"];
            this.ecmExportedDate = data["ecmExportedDate"];
            this.ecmUploadEnabled = data["ecmUploadEnabled"];
            this.active = data["active"];
            this.setAsOfDate = data["setAsOfDate"];
            if (data["entityIds"] && data["entityIds"].constructor === Array) {
                this.entityIds = [];
                for (let item of data["entityIds"])
                    this.entityIds.push(item);
            }
            this.entityType = data["entityType"];
            this.requirementAttachDate = data["requirementAttachDate"];
            this.docDefinitionCode = data["docDefinitionCode"];
            this.createdByFirstname = data["createdByFirstname"];
            this.createdByLastname = data["createdByLastname"];
        }
    }

    static fromJS(data: any): DocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentDefinitionId"] = this.documentDefinitionId;
        data["documentDefinitionName"] = this.documentDefinitionName;
        data["file"] = this.file;
        data["name"] = this.name;
        data["alternateName"] = this.alternateName;
        data["description"] = this.description;
        data["recievedDate"] = this.recievedDate;
        data["asOfDate"] = this.asOfDate;
        data["expirationDate"] = this.expirationDate;
        data["uploadDate"] = this.uploadDate;
        data["primary"] = this.primary;
        data["notes"] = this.notes;
        data["isIIS"] = this.isIIS;
        data["dealId"] = this.dealId;
        data["requirementId"] = this.requirementId;
        data["mimeType"] = this.mimeType;
        data["fileGuid"] = this.fileGuid;
        data["requirementAttachmentCount"] = this.requirementAttachmentCount;
        if (this.attachedRequirements && this.attachedRequirements.constructor === Array) {
            data["attachedRequirements"] = [];
            for (let item of this.attachedRequirements)
                data["attachedRequirements"].push(item.toJSON());
        }
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate;
        data["lastModBy"] = this.lastModBy;
        data["lastModByFirstname"] = this.lastModByFirstname;
        data["lastModByLastname"] = this.lastModByLastname;
        data["lastModByDate"] = this.lastModByDate;
        data["ecmExportReady"] = this.ecmExportReady;
        data["ecmExported"] = this.ecmExported;
        data["ecmCabinetCode"] = this.ecmCabinetCode;
        data["ecmFileName"] = this.ecmFileName;
        data["ecmExportedBy"] = this.ecmExportedBy;
        data["ecmExportedDate"] = this.ecmExportedDate;
        data["ecmUploadEnabled"] = this.ecmUploadEnabled;
        data["active"] = this.active;
        data["setAsOfDate"] = this.setAsOfDate;
        if (this.entityIds && this.entityIds.constructor === Array) {
            data["entityIds"] = [];
            for (let item of this.entityIds)
                data["entityIds"].push(item);
        }
        data["entityType"] = this.entityType;
        data["requirementAttachDate"] = this.requirementAttachDate;
        data["docDefinitionCode"] = this.docDefinitionCode;
        data["createdByFirstname"] = this.createdByFirstname;
        data["createdByLastname"] = this.createdByLastname;
        return data; 
    }
}

export interface IDocumentDto {
    id?: number | undefined;
    documentDefinitionId?: number | undefined;
    documentDefinitionName?: string | undefined;
    file?: string | undefined;
    name?: string | undefined;
    alternateName?: string | undefined;
    description?: string | undefined;
    recievedDate?: string | undefined;
    asOfDate?: string | undefined;
    expirationDate?: string | undefined;
    uploadDate?: string | undefined;
    primary?: boolean | undefined;
    notes?: string | undefined;
    isIIS?: boolean | undefined;
    dealId?: number | undefined;
    requirementId?: number | undefined;
    mimeType?: string | undefined;
    fileGuid?: string | undefined;
    requirementAttachmentCount?: number | undefined;
    attachedRequirements?: RequirementDto[] | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByFirstname?: string | undefined;
    lastModByLastname?: string | undefined;
    lastModByDate?: string | undefined;
    ecmExportReady?: boolean | undefined;
    ecmExported?: boolean | undefined;
    ecmCabinetCode?: string | undefined;
    ecmFileName?: string | undefined;
    ecmExportedBy?: string | undefined;
    ecmExportedDate?: string | undefined;
    ecmUploadEnabled?: boolean | undefined;
    active?: boolean | undefined;
    setAsOfDate?: boolean | undefined;
    entityIds?: number[] | undefined;
    entityType?: string | undefined;
    requirementAttachDate?: string | undefined;
    docDefinitionCode?: string | undefined;
    createdByFirstname?: string | undefined;
    createdByLastname?: string | undefined;
}

export class RequirementDto implements IRequirementDto {
    requirementId?: number | undefined;
    reqDefinitionId?: number | undefined;
    reqDealId?: number | undefined;
    requirementDealId?: number | undefined;
    documentDefinitionId?: number | undefined;
    documentDefinitionName?: string | undefined;
    documents?: DocumentDto[] | undefined;
    baseReqQuestions?: ReqDefinitionQuestionCustomModel[] | undefined;
    ticklerReqQuestions?: ReqTicklerQuestionCustomModel[] | undefined;
    documentId?: number | undefined;
    primaryDocumentName?: string | undefined;
    statusDescription?: string | undefined;
    status?: string | undefined;
    description?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    reqType?: string | undefined;
    typeCode?: string | undefined;
    valueLabel?: string | undefined;
    compareFlag?: string | undefined;
    showCompareFlag?: string | undefined;
    expectedValue?: string | undefined;
    actualValue?: string | undefined;
    actualValueEnabled?: boolean | undefined;
    active?: boolean | undefined;
    manualRequirement?: boolean | undefined;
    dueDate?: string | undefined;
    asOfDate?: string | undefined;
    expirationDate?: string | undefined;
    sourceCode?: string | undefined;
    source?: string | undefined;
    entityType?: string | undefined;
    initiateProcessId?: string | undefined;
    processHistoryId?: number | undefined;
    processId?: string | undefined;
    stageId?: string | undefined;
    functionId?: string | undefined;
    processStageFunctionId?: number | undefined;
    deferStageName?: string | undefined;
    stageName?: string | undefined;
    stageStatus?: string | undefined;
    assignedTo?: string | undefined;
    assignedToFullName?: string | undefined;
    createdBy?: string | undefined;
    deferToStage?: string | undefined;
    comment?: string | undefined;
    compareDataType?: string | undefined;
    compareFunctionName?: string | undefined;
    exception?: boolean | undefined;
    complete?: boolean | undefined;
    daysDue?: number | undefined;
    isTickler?: boolean | undefined;
    group?: string | undefined;
    requireDocument?: boolean | undefined;
    missingDocument?: boolean | undefined;
    requireAsOfDate?: boolean | undefined;
    expirationPeriodDays?: number | undefined;
    priority?: number | undefined;
    ticklerDefinitionId?: number | undefined;
    exceptionFlag?: boolean | undefined;
    mitigatingFactors?: string | undefined;
    stageType?: string | undefined;
    isAttention?: boolean | undefined;
    attentionType?: string | undefined;
    actionType?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByDate?: string | undefined;
    apReqNeededforclosing?: boolean | undefined;
    coProcessNeededforclosing?: boolean | undefined;
    isSubjectTo?: boolean | undefined;
    isMitigatingFactors?: boolean | undefined;
    subjectTo?: string | undefined;
    loanRequestType?: string | undefined;
    dealId?: number | undefined;
    isSaveComplete?: boolean | undefined;
    lastModbyFirstname?: string | undefined;
    lastModbyLastname?: string | undefined;
    documentCount?: number | undefined;
    hardstop?: boolean | undefined;
    statusType?: string | undefined;
    frequentlyUsed?: number | undefined;
    displayValue?: string | undefined;
    threadId?: number | undefined;
    threadName?: string | undefined;
    isProcessPortlet?: boolean | undefined;

    constructor(data?: IRequirementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requirementId = data["requirementId"];
            this.reqDefinitionId = data["reqDefinitionId"];
            this.reqDealId = data["reqDealId"];
            this.requirementDealId = data["requirementDealId"];
            this.documentDefinitionId = data["documentDefinitionId"];
            this.documentDefinitionName = data["documentDefinitionName"];
            if (data["documents"] && data["documents"].constructor === Array) {
                this.documents = [];
                for (let item of data["documents"])
                    this.documents.push(DocumentDto.fromJS(item));
            }
            if (data["baseReqQuestions"] && data["baseReqQuestions"].constructor === Array) {
                this.baseReqQuestions = [];
                for (let item of data["baseReqQuestions"])
                    this.baseReqQuestions.push(ReqDefinitionQuestionCustomModel.fromJS(item));
            }
            if (data["ticklerReqQuestions"] && data["ticklerReqQuestions"].constructor === Array) {
                this.ticklerReqQuestions = [];
                for (let item of data["ticklerReqQuestions"])
                    this.ticklerReqQuestions.push(ReqTicklerQuestionCustomModel.fromJS(item));
            }
            this.documentId = data["documentId"];
            this.primaryDocumentName = data["primaryDocumentName"];
            this.statusDescription = data["statusDescription"];
            this.status = data["status"];
            this.description = data["description"];
            this.name = data["name"];
            this.type = data["type"];
            this.reqType = data["reqType"];
            this.typeCode = data["typeCode"];
            this.valueLabel = data["valueLabel"];
            this.compareFlag = data["compareFlag"];
            this.showCompareFlag = data["showCompareFlag"];
            this.expectedValue = data["expectedValue"];
            this.actualValue = data["actualValue"];
            this.actualValueEnabled = data["actualValueEnabled"];
            this.active = data["active"];
            this.manualRequirement = data["manualRequirement"];
            this.dueDate = data["dueDate"];
            this.asOfDate = data["asOfDate"];
            this.expirationDate = data["expirationDate"];
            this.sourceCode = data["sourceCode"];
            this.source = data["source"];
            this.entityType = data["entityType"];
            this.initiateProcessId = data["initiateProcessId"];
            this.processHistoryId = data["processHistoryId"];
            this.processId = data["processId"];
            this.stageId = data["stageId"];
            this.functionId = data["functionId"];
            this.processStageFunctionId = data["processStageFunctionId"];
            this.deferStageName = data["deferStageName"];
            this.stageName = data["stageName"];
            this.stageStatus = data["stageStatus"];
            this.assignedTo = data["assignedTo"];
            this.assignedToFullName = data["assignedToFullName"];
            this.createdBy = data["createdBy"];
            this.deferToStage = data["deferToStage"];
            this.comment = data["comment"];
            this.compareDataType = data["compareDataType"];
            this.compareFunctionName = data["compareFunctionName"];
            this.exception = data["exception"];
            this.complete = data["complete"];
            this.daysDue = data["daysDue"];
            this.isTickler = data["isTickler"];
            this.group = data["group"];
            this.requireDocument = data["requireDocument"];
            this.missingDocument = data["missingDocument"];
            this.requireAsOfDate = data["requireAsOfDate"];
            this.expirationPeriodDays = data["expirationPeriodDays"];
            this.priority = data["priority"];
            this.ticklerDefinitionId = data["ticklerDefinitionId"];
            this.exceptionFlag = data["exceptionFlag"];
            this.mitigatingFactors = data["mitigatingFactors"];
            this.stageType = data["stageType"];
            this.isAttention = data["isAttention"];
            this.attentionType = data["attentionType"];
            this.actionType = data["actionType"];
            this.createdDate = data["createdDate"];
            this.lastModBy = data["lastModBy"];
            this.lastModByDate = data["lastModByDate"];
            this.apReqNeededforclosing = data["apReqNeededforclosing"];
            this.coProcessNeededforclosing = data["coProcessNeededforclosing"];
            this.isSubjectTo = data["isSubjectTo"];
            this.isMitigatingFactors = data["isMitigatingFactors"];
            this.subjectTo = data["subjectTo"];
            this.loanRequestType = data["loanRequestType"];
            this.dealId = data["dealId"];
            this.isSaveComplete = data["isSaveComplete"];
            this.lastModbyFirstname = data["lastModbyFirstname"];
            this.lastModbyLastname = data["lastModbyLastname"];
            this.documentCount = data["documentCount"];
            this.hardstop = data["hardstop"];
            this.statusType = data["statusType"];
            this.frequentlyUsed = data["frequentlyUsed"];
            this.displayValue = data["displayValue"];
            this.threadId = data["threadId"];
            this.threadName = data["threadName"];
            this.isProcessPortlet = data["isProcessPortlet"];
        }
    }

    static fromJS(data: any): RequirementDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requirementId"] = this.requirementId;
        data["reqDefinitionId"] = this.reqDefinitionId;
        data["reqDealId"] = this.reqDealId;
        data["requirementDealId"] = this.requirementDealId;
        data["documentDefinitionId"] = this.documentDefinitionId;
        data["documentDefinitionName"] = this.documentDefinitionName;
        if (this.documents && this.documents.constructor === Array) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        if (this.baseReqQuestions && this.baseReqQuestions.constructor === Array) {
            data["baseReqQuestions"] = [];
            for (let item of this.baseReqQuestions)
                data["baseReqQuestions"].push(item.toJSON());
        }
        if (this.ticklerReqQuestions && this.ticklerReqQuestions.constructor === Array) {
            data["ticklerReqQuestions"] = [];
            for (let item of this.ticklerReqQuestions)
                data["ticklerReqQuestions"].push(item.toJSON());
        }
        data["documentId"] = this.documentId;
        data["primaryDocumentName"] = this.primaryDocumentName;
        data["statusDescription"] = this.statusDescription;
        data["status"] = this.status;
        data["description"] = this.description;
        data["name"] = this.name;
        data["type"] = this.type;
        data["reqType"] = this.reqType;
        data["typeCode"] = this.typeCode;
        data["valueLabel"] = this.valueLabel;
        data["compareFlag"] = this.compareFlag;
        data["showCompareFlag"] = this.showCompareFlag;
        data["expectedValue"] = this.expectedValue;
        data["actualValue"] = this.actualValue;
        data["actualValueEnabled"] = this.actualValueEnabled;
        data["active"] = this.active;
        data["manualRequirement"] = this.manualRequirement;
        data["dueDate"] = this.dueDate;
        data["asOfDate"] = this.asOfDate;
        data["expirationDate"] = this.expirationDate;
        data["sourceCode"] = this.sourceCode;
        data["source"] = this.source;
        data["entityType"] = this.entityType;
        data["initiateProcessId"] = this.initiateProcessId;
        data["processHistoryId"] = this.processHistoryId;
        data["processId"] = this.processId;
        data["stageId"] = this.stageId;
        data["functionId"] = this.functionId;
        data["processStageFunctionId"] = this.processStageFunctionId;
        data["deferStageName"] = this.deferStageName;
        data["stageName"] = this.stageName;
        data["stageStatus"] = this.stageStatus;
        data["assignedTo"] = this.assignedTo;
        data["assignedToFullName"] = this.assignedToFullName;
        data["createdBy"] = this.createdBy;
        data["deferToStage"] = this.deferToStage;
        data["comment"] = this.comment;
        data["compareDataType"] = this.compareDataType;
        data["compareFunctionName"] = this.compareFunctionName;
        data["exception"] = this.exception;
        data["complete"] = this.complete;
        data["daysDue"] = this.daysDue;
        data["isTickler"] = this.isTickler;
        data["group"] = this.group;
        data["requireDocument"] = this.requireDocument;
        data["missingDocument"] = this.missingDocument;
        data["requireAsOfDate"] = this.requireAsOfDate;
        data["expirationPeriodDays"] = this.expirationPeriodDays;
        data["priority"] = this.priority;
        data["ticklerDefinitionId"] = this.ticklerDefinitionId;
        data["exceptionFlag"] = this.exceptionFlag;
        data["mitigatingFactors"] = this.mitigatingFactors;
        data["stageType"] = this.stageType;
        data["isAttention"] = this.isAttention;
        data["attentionType"] = this.attentionType;
        data["actionType"] = this.actionType;
        data["createdDate"] = this.createdDate;
        data["lastModBy"] = this.lastModBy;
        data["lastModByDate"] = this.lastModByDate;
        data["apReqNeededforclosing"] = this.apReqNeededforclosing;
        data["coProcessNeededforclosing"] = this.coProcessNeededforclosing;
        data["isSubjectTo"] = this.isSubjectTo;
        data["isMitigatingFactors"] = this.isMitigatingFactors;
        data["subjectTo"] = this.subjectTo;
        data["loanRequestType"] = this.loanRequestType;
        data["dealId"] = this.dealId;
        data["isSaveComplete"] = this.isSaveComplete;
        data["lastModbyFirstname"] = this.lastModbyFirstname;
        data["lastModbyLastname"] = this.lastModbyLastname;
        data["documentCount"] = this.documentCount;
        data["hardstop"] = this.hardstop;
        data["statusType"] = this.statusType;
        data["frequentlyUsed"] = this.frequentlyUsed;
        data["displayValue"] = this.displayValue;
        data["threadId"] = this.threadId;
        data["threadName"] = this.threadName;
        data["isProcessPortlet"] = this.isProcessPortlet;
        return data; 
    }
}

export interface IRequirementDto {
    requirementId?: number | undefined;
    reqDefinitionId?: number | undefined;
    reqDealId?: number | undefined;
    requirementDealId?: number | undefined;
    documentDefinitionId?: number | undefined;
    documentDefinitionName?: string | undefined;
    documents?: DocumentDto[] | undefined;
    baseReqQuestions?: ReqDefinitionQuestionCustomModel[] | undefined;
    ticklerReqQuestions?: ReqTicklerQuestionCustomModel[] | undefined;
    documentId?: number | undefined;
    primaryDocumentName?: string | undefined;
    statusDescription?: string | undefined;
    status?: string | undefined;
    description?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    reqType?: string | undefined;
    typeCode?: string | undefined;
    valueLabel?: string | undefined;
    compareFlag?: string | undefined;
    showCompareFlag?: string | undefined;
    expectedValue?: string | undefined;
    actualValue?: string | undefined;
    actualValueEnabled?: boolean | undefined;
    active?: boolean | undefined;
    manualRequirement?: boolean | undefined;
    dueDate?: string | undefined;
    asOfDate?: string | undefined;
    expirationDate?: string | undefined;
    sourceCode?: string | undefined;
    source?: string | undefined;
    entityType?: string | undefined;
    initiateProcessId?: string | undefined;
    processHistoryId?: number | undefined;
    processId?: string | undefined;
    stageId?: string | undefined;
    functionId?: string | undefined;
    processStageFunctionId?: number | undefined;
    deferStageName?: string | undefined;
    stageName?: string | undefined;
    stageStatus?: string | undefined;
    assignedTo?: string | undefined;
    assignedToFullName?: string | undefined;
    createdBy?: string | undefined;
    deferToStage?: string | undefined;
    comment?: string | undefined;
    compareDataType?: string | undefined;
    compareFunctionName?: string | undefined;
    exception?: boolean | undefined;
    complete?: boolean | undefined;
    daysDue?: number | undefined;
    isTickler?: boolean | undefined;
    group?: string | undefined;
    requireDocument?: boolean | undefined;
    missingDocument?: boolean | undefined;
    requireAsOfDate?: boolean | undefined;
    expirationPeriodDays?: number | undefined;
    priority?: number | undefined;
    ticklerDefinitionId?: number | undefined;
    exceptionFlag?: boolean | undefined;
    mitigatingFactors?: string | undefined;
    stageType?: string | undefined;
    isAttention?: boolean | undefined;
    attentionType?: string | undefined;
    actionType?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModByDate?: string | undefined;
    apReqNeededforclosing?: boolean | undefined;
    coProcessNeededforclosing?: boolean | undefined;
    isSubjectTo?: boolean | undefined;
    isMitigatingFactors?: boolean | undefined;
    subjectTo?: string | undefined;
    loanRequestType?: string | undefined;
    dealId?: number | undefined;
    isSaveComplete?: boolean | undefined;
    lastModbyFirstname?: string | undefined;
    lastModbyLastname?: string | undefined;
    documentCount?: number | undefined;
    hardstop?: boolean | undefined;
    statusType?: string | undefined;
    frequentlyUsed?: number | undefined;
    displayValue?: string | undefined;
    threadId?: number | undefined;
    threadName?: string | undefined;
    isProcessPortlet?: boolean | undefined;
}

export class RequirementQuestion implements IRequirementQuestion {
    id?: number | undefined;
    exception?: boolean | undefined;
    valueLabel?: string | undefined;
    compareFlag?: string | undefined;
    showCompareFlag?: string | undefined;
    expectedValue?: string | undefined;
    actualValue?: string | undefined;
    lastModBy?: string | undefined;

    constructor(data?: IRequirementQuestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.exception = data["exception"];
            this.valueLabel = data["valueLabel"];
            this.compareFlag = data["compareFlag"];
            this.showCompareFlag = data["showCompareFlag"];
            this.expectedValue = data["expectedValue"];
            this.actualValue = data["actualValue"];
            this.lastModBy = data["lastModBy"];
        }
    }

    static fromJS(data: any): RequirementQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["exception"] = this.exception;
        data["valueLabel"] = this.valueLabel;
        data["compareFlag"] = this.compareFlag;
        data["showCompareFlag"] = this.showCompareFlag;
        data["expectedValue"] = this.expectedValue;
        data["actualValue"] = this.actualValue;
        data["lastModBy"] = this.lastModBy;
        return data; 
    }
}

export interface IRequirementQuestion {
    id?: number | undefined;
    exception?: boolean | undefined;
    valueLabel?: string | undefined;
    compareFlag?: string | undefined;
    showCompareFlag?: string | undefined;
    expectedValue?: string | undefined;
    actualValue?: string | undefined;
    lastModBy?: string | undefined;
}

export class RequirementComment implements IRequirementComment {
    id?: number | undefined;
    comment?: string | undefined;
    isSubjectTo?: boolean | undefined;
    isMitigatingFactors?: boolean | undefined;
    subjectTo?: string | undefined;
    mitigatingFactors?: string | undefined;
    dueDate?: string | undefined;
    lastModBy?: string | undefined;

    constructor(data?: IRequirementComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.comment = data["comment"];
            this.isSubjectTo = data["isSubjectTo"];
            this.isMitigatingFactors = data["isMitigatingFactors"];
            this.subjectTo = data["subjectTo"];
            this.mitigatingFactors = data["mitigatingFactors"];
            this.dueDate = data["dueDate"];
            this.lastModBy = data["lastModBy"];
        }
    }

    static fromJS(data: any): RequirementComment {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["comment"] = this.comment;
        data["isSubjectTo"] = this.isSubjectTo;
        data["isMitigatingFactors"] = this.isMitigatingFactors;
        data["subjectTo"] = this.subjectTo;
        data["mitigatingFactors"] = this.mitigatingFactors;
        data["dueDate"] = this.dueDate;
        data["lastModBy"] = this.lastModBy;
        return data; 
    }
}

export interface IRequirementComment {
    id?: number | undefined;
    comment?: string | undefined;
    isSubjectTo?: boolean | undefined;
    isMitigatingFactors?: boolean | undefined;
    subjectTo?: string | undefined;
    mitigatingFactors?: string | undefined;
    dueDate?: string | undefined;
    lastModBy?: string | undefined;
}

export class TenantDto implements ITenantDto {
    tenantId?: number | undefined;
    tenantcyName?: string | undefined;
    connectionString?: string | undefined;
    loggerConnectionString?: string | undefined;
    messageBrokerKey?: string | undefined;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenantcyName = data["tenantcyName"];
            this.connectionString = data["connectionString"];
            this.loggerConnectionString = data["loggerConnectionString"];
            this.messageBrokerKey = data["messageBrokerKey"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenantcyName"] = this.tenantcyName;
        data["connectionString"] = this.connectionString;
        data["loggerConnectionString"] = this.loggerConnectionString;
        data["messageBrokerKey"] = this.messageBrokerKey;
        return data; 
    }
}

export interface ITenantDto {
    tenantId?: number | undefined;
    tenantcyName?: string | undefined;
    connectionString?: string | undefined;
    loggerConnectionString?: string | undefined;
    messageBrokerKey?: string | undefined;
}

export class UserFullProfileDto implements IUserFullProfileDto {
    userId?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    title?: string | undefined;
    phoneNumber?: string | undefined;
    faxNumber?: string | undefined;
    email?: string | undefined;
    nmlsNumber?: string | undefined;
    officeNumber?: string | undefined;
    fileDownloadModeEnabled?: boolean | undefined;
    manager?: string | undefined;
    region?: number | undefined;
    branch?: number | undefined;
    department?: number | undefined;
    costCenter?: number | undefined;
    employeeLoans?: boolean | undefined;
    userProfileURL?: string | undefined;
    loanAssistant?: string | undefined;

    constructor(data?: IUserFullProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.title = data["title"];
            this.phoneNumber = data["phoneNumber"];
            this.faxNumber = data["faxNumber"];
            this.email = data["email"];
            this.nmlsNumber = data["nmlsNumber"];
            this.officeNumber = data["officeNumber"];
            this.fileDownloadModeEnabled = data["fileDownloadModeEnabled"];
            this.manager = data["manager"];
            this.region = data["region"];
            this.branch = data["branch"];
            this.department = data["department"];
            this.costCenter = data["costCenter"];
            this.employeeLoans = data["employeeLoans"];
            this.userProfileURL = data["userProfileURL"];
            this.loanAssistant = data["loanAssistant"];
        }
    }

    static fromJS(data: any): UserFullProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserFullProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["title"] = this.title;
        data["phoneNumber"] = this.phoneNumber;
        data["faxNumber"] = this.faxNumber;
        data["email"] = this.email;
        data["nmlsNumber"] = this.nmlsNumber;
        data["officeNumber"] = this.officeNumber;
        data["fileDownloadModeEnabled"] = this.fileDownloadModeEnabled;
        data["manager"] = this.manager;
        data["region"] = this.region;
        data["branch"] = this.branch;
        data["department"] = this.department;
        data["costCenter"] = this.costCenter;
        data["employeeLoans"] = this.employeeLoans;
        data["userProfileURL"] = this.userProfileURL;
        data["loanAssistant"] = this.loanAssistant;
        return data; 
    }
}

export interface IUserFullProfileDto {
    userId?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    title?: string | undefined;
    phoneNumber?: string | undefined;
    faxNumber?: string | undefined;
    email?: string | undefined;
    nmlsNumber?: string | undefined;
    officeNumber?: string | undefined;
    fileDownloadModeEnabled?: boolean | undefined;
    manager?: string | undefined;
    region?: number | undefined;
    branch?: number | undefined;
    department?: number | undefined;
    costCenter?: number | undefined;
    employeeLoans?: boolean | undefined;
    userProfileURL?: string | undefined;
    loanAssistant?: string | undefined;
}

export class UserOutOfOfficeDto implements IUserOutOfOfficeDto {
    userId?: string | undefined;
    interimOfficerId?: string | undefined;
    startDate?: string | undefined;
    endDate?: string | undefined;
    isOutOfOfficeRangeSet?: boolean | undefined;
    isOutOfOffice?: boolean | undefined;

    constructor(data?: IUserOutOfOfficeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.interimOfficerId = data["interimOfficerId"];
            this.startDate = data["startDate"];
            this.endDate = data["endDate"];
            this.isOutOfOfficeRangeSet = data["isOutOfOfficeRangeSet"];
            this.isOutOfOffice = data["isOutOfOffice"];
        }
    }

    static fromJS(data: any): UserOutOfOfficeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserOutOfOfficeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["interimOfficerId"] = this.interimOfficerId;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        data["isOutOfOfficeRangeSet"] = this.isOutOfOfficeRangeSet;
        data["isOutOfOffice"] = this.isOutOfOffice;
        return data; 
    }
}

export interface IUserOutOfOfficeDto {
    userId?: string | undefined;
    interimOfficerId?: string | undefined;
    startDate?: string | undefined;
    endDate?: string | undefined;
    isOutOfOfficeRangeSet?: boolean | undefined;
    isOutOfOffice?: boolean | undefined;
}

export class UserPreferenceDto implements IUserPreferenceDto {
    userPrefId?: number | undefined;
    userId?: string | undefined;
    preferenceCode?: string | undefined;
    preferences?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModDate?: string | undefined;
    isDefaultSetting?: boolean | undefined;

    constructor(data?: IUserPreferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userPrefId = data["userPrefId"];
            this.userId = data["userId"];
            this.preferenceCode = data["preferenceCode"];
            this.preferences = data["preferences"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"];
            this.lastModBy = data["lastModBy"];
            this.lastModDate = data["lastModDate"];
            this.isDefaultSetting = data["isDefaultSetting"];
        }
    }

    static fromJS(data: any): UserPreferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserPreferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userPrefId"] = this.userPrefId;
        data["userId"] = this.userId;
        data["preferenceCode"] = this.preferenceCode;
        data["preferences"] = this.preferences;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate;
        data["lastModBy"] = this.lastModBy;
        data["lastModDate"] = this.lastModDate;
        data["isDefaultSetting"] = this.isDefaultSetting;
        return data; 
    }
}

export interface IUserPreferenceDto {
    userPrefId?: number | undefined;
    userId?: string | undefined;
    preferenceCode?: string | undefined;
    preferences?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: string | undefined;
    lastModBy?: string | undefined;
    lastModDate?: string | undefined;
    isDefaultSetting?: boolean | undefined;
}

export class DealDto implements IDealDto {
    dealId?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    estimatedClosingDate?: string | undefined;
    amount?: number | undefined;
    fee?: number | undefined;
    applicationDate?: string | undefined;
    completeDate?: string | undefined;
    status?: string | undefined;
    statusCode?: string | undefined;
    processHistoryId?: number | undefined;
    processId?: string | undefined;
    openRequirements?: number | undefined;
    isEmployeeDeal?: boolean | undefined;
    private?: boolean | undefined;
    active?: boolean | undefined;
    stageId?: string | undefined;
    stageStatus?: string | undefined;

    constructor(data?: IDealDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dealId = data["dealId"];
            this.name = data["name"];
            this.description = data["description"];
            this.estimatedClosingDate = data["estimatedClosingDate"];
            this.amount = data["amount"];
            this.fee = data["fee"];
            this.applicationDate = data["applicationDate"];
            this.completeDate = data["completeDate"];
            this.status = data["status"];
            this.statusCode = data["statusCode"];
            this.processHistoryId = data["processHistoryId"];
            this.processId = data["processId"];
            this.openRequirements = data["openRequirements"];
            this.isEmployeeDeal = data["isEmployeeDeal"];
            this.private = data["private"];
            this.active = data["active"];
            this.stageId = data["stageId"];
            this.stageStatus = data["stageStatus"];
        }
    }

    static fromJS(data: any): DealDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dealId"] = this.dealId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["estimatedClosingDate"] = this.estimatedClosingDate;
        data["amount"] = this.amount;
        data["fee"] = this.fee;
        data["applicationDate"] = this.applicationDate;
        data["completeDate"] = this.completeDate;
        data["status"] = this.status;
        data["statusCode"] = this.statusCode;
        data["processHistoryId"] = this.processHistoryId;
        data["processId"] = this.processId;
        data["openRequirements"] = this.openRequirements;
        data["isEmployeeDeal"] = this.isEmployeeDeal;
        data["private"] = this.private;
        data["active"] = this.active;
        data["stageId"] = this.stageId;
        data["stageStatus"] = this.stageStatus;
        return data; 
    }
}

export interface IDealDto {
    dealId?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    estimatedClosingDate?: string | undefined;
    amount?: number | undefined;
    fee?: number | undefined;
    applicationDate?: string | undefined;
    completeDate?: string | undefined;
    status?: string | undefined;
    statusCode?: string | undefined;
    processHistoryId?: number | undefined;
    processId?: string | undefined;
    openRequirements?: number | undefined;
    isEmployeeDeal?: boolean | undefined;
    private?: boolean | undefined;
    active?: boolean | undefined;
    stageId?: string | undefined;
    stageStatus?: string | undefined;
}

export class CoPermission implements ICoPermission {
    permissionid_05?: number | undefined;
    name_10?: string | undefined;
    permissiondesc_10?: string | undefined;
    parentpermissionid_05?: number | undefined;
    createdby_10?: string | undefined;
    createddate_22?: string | undefined;
    lastmodby_10?: string | undefined;
    lastmoddate_22?: string | undefined;
    accesstimestamp_90?: string | undefined;

    constructor(data?: ICoPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.permissionid_05 = data["permissionid_05"];
            this.name_10 = data["name_10"];
            this.permissiondesc_10 = data["permissiondesc_10"];
            this.parentpermissionid_05 = data["parentpermissionid_05"];
            this.createdby_10 = data["createdby_10"];
            this.createddate_22 = data["createddate_22"];
            this.lastmodby_10 = data["lastmodby_10"];
            this.lastmoddate_22 = data["lastmoddate_22"];
            this.accesstimestamp_90 = data["accesstimestamp_90"];
        }
    }

    static fromJS(data: any): CoPermission {
        data = typeof data === 'object' ? data : {};
        let result = new CoPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionid_05"] = this.permissionid_05;
        data["name_10"] = this.name_10;
        data["permissiondesc_10"] = this.permissiondesc_10;
        data["parentpermissionid_05"] = this.parentpermissionid_05;
        data["createdby_10"] = this.createdby_10;
        data["createddate_22"] = this.createddate_22;
        data["lastmodby_10"] = this.lastmodby_10;
        data["lastmoddate_22"] = this.lastmoddate_22;
        data["accesstimestamp_90"] = this.accesstimestamp_90;
        return data; 
    }
}

export interface ICoPermission {
    permissionid_05?: number | undefined;
    name_10?: string | undefined;
    permissiondesc_10?: string | undefined;
    parentpermissionid_05?: number | undefined;
    createdby_10?: string | undefined;
    createddate_22?: string | undefined;
    lastmodby_10?: string | undefined;
    lastmoddate_22?: string | undefined;
    accesstimestamp_90?: string | undefined;
}

export class WorkFlowRequestDto implements IWorkFlowRequestDto {
    debug?: boolean | undefined;
    processHistoryId?: number | undefined;
    parentProcessHistoryId?: number | undefined;
    submittedToCf?: boolean | undefined;
    passedParameters?: string | undefined;
    processStageFunctionType?: string | undefined;
    processStageFunctionId?: number | undefined;
    processId?: string | undefined;
    stageId?: string | undefined;
    containerId?: string | undefined;
    containerObjectId?: string | undefined;
    functionId?: string | undefined;
    resultStageId?: string | undefined;
    requestUserId?: string | undefined;
    assignedUserId?: string | undefined;
    lockUserId?: string | undefined;
    reqActualValue?: string | undefined;
    reqDueDate?: string | undefined;
    documentId?: number | undefined;
    currentDate?: string | undefined;
    dueDate?: string | undefined;
    stageDueDate?: string | undefined;
    pendDate?: string | undefined;

    constructor(data?: IWorkFlowRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.debug = data["debug"];
            this.processHistoryId = data["processHistoryId"];
            this.parentProcessHistoryId = data["parentProcessHistoryId"];
            this.submittedToCf = data["submittedToCf"];
            this.passedParameters = data["passedParameters"];
            this.processStageFunctionType = data["processStageFunctionType"];
            this.processStageFunctionId = data["processStageFunctionId"];
            this.processId = data["processId"];
            this.stageId = data["stageId"];
            this.containerId = data["containerId"];
            this.containerObjectId = data["containerObjectId"];
            this.functionId = data["functionId"];
            this.resultStageId = data["resultStageId"];
            this.requestUserId = data["requestUserId"];
            this.assignedUserId = data["assignedUserId"];
            this.lockUserId = data["lockUserId"];
            this.reqActualValue = data["reqActualValue"];
            this.reqDueDate = data["reqDueDate"];
            this.documentId = data["documentId"];
            this.currentDate = data["currentDate"];
            this.dueDate = data["dueDate"];
            this.stageDueDate = data["stageDueDate"];
            this.pendDate = data["pendDate"];
        }
    }

    static fromJS(data: any): WorkFlowRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkFlowRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debug"] = this.debug;
        data["processHistoryId"] = this.processHistoryId;
        data["parentProcessHistoryId"] = this.parentProcessHistoryId;
        data["submittedToCf"] = this.submittedToCf;
        data["passedParameters"] = this.passedParameters;
        data["processStageFunctionType"] = this.processStageFunctionType;
        data["processStageFunctionId"] = this.processStageFunctionId;
        data["processId"] = this.processId;
        data["stageId"] = this.stageId;
        data["containerId"] = this.containerId;
        data["containerObjectId"] = this.containerObjectId;
        data["functionId"] = this.functionId;
        data["resultStageId"] = this.resultStageId;
        data["requestUserId"] = this.requestUserId;
        data["assignedUserId"] = this.assignedUserId;
        data["lockUserId"] = this.lockUserId;
        data["reqActualValue"] = this.reqActualValue;
        data["reqDueDate"] = this.reqDueDate;
        data["documentId"] = this.documentId;
        data["currentDate"] = this.currentDate;
        data["dueDate"] = this.dueDate;
        data["stageDueDate"] = this.stageDueDate;
        data["pendDate"] = this.pendDate;
        return data; 
    }
}

export interface IWorkFlowRequestDto {
    debug?: boolean | undefined;
    processHistoryId?: number | undefined;
    parentProcessHistoryId?: number | undefined;
    submittedToCf?: boolean | undefined;
    passedParameters?: string | undefined;
    processStageFunctionType?: string | undefined;
    processStageFunctionId?: number | undefined;
    processId?: string | undefined;
    stageId?: string | undefined;
    containerId?: string | undefined;
    containerObjectId?: string | undefined;
    functionId?: string | undefined;
    resultStageId?: string | undefined;
    requestUserId?: string | undefined;
    assignedUserId?: string | undefined;
    lockUserId?: string | undefined;
    reqActualValue?: string | undefined;
    reqDueDate?: string | undefined;
    documentId?: number | undefined;
    currentDate?: string | undefined;
    dueDate?: string | undefined;
    stageDueDate?: string | undefined;
    pendDate?: string | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}